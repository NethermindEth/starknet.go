# NewFixedSizeMerkleTree

Creates a new fixed-size Merkle tree from the provided leaf values. The function builds the tree bottom-up by repeatedly hashing pairs of nodes using `MerkleHash`, stores all intermediate branches for efficient proof generation, and computes the root hash.

## Function Signature

```go
func NewFixedSizeMerkleTree(leaves ...*big.Int) *FixedSizeMerkleTree
```

**Source:** [merkle.go:L27-L36](https://github.com/NethermindEth/starknet.go/blob/main/merkle/merkle.go#L27-L36)

## Parameters

- `leaves` (...*big.Int): Variable number of `*big.Int` values representing the leaf nodes

## Returns

- `*FixedSizeMerkleTree`: A pointer to the constructed Merkle tree with computed root

## Type Definition

The returned `FixedSizeMerkleTree` struct contains:

```go
type FixedSizeMerkleTree struct {
	Leaves   []*big.Int      // The original leaf values
	Branches [][]*big.Int    // All intermediate levels of the tree
	Root     *big.Int        // The root hash representing the entire tree
}
```

**Source:** [merkle.go:L10-L14](https://github.com/NethermindEth/starknet.go/blob/main/merkle/merkle.go#L10-L14)

## How It Works

The tree construction process:

1. Accepts any number of leaf values as variadic parameters
2. Builds the tree bottom-up by repeatedly hashing pairs of nodes using `MerkleHash`
3. If there's an odd number of nodes at any level, the last node is paired with zero
4. Stores all intermediate branches in a 2D slice for efficient proof generation
5. Computes and stores the root hash at the top level

## Usage Example

```go
package main

import (
	"fmt"
	"math/big"

	"github.com/NethermindEth/starknet.go/merkle"
)

func main() {
	// Create leaves for the tree
	leaf1 := big.NewInt(10)
	leaf2 := big.NewInt(20)
	leaf3 := big.NewInt(30)
	leaf4 := big.NewInt(40)

	// Create a fixed-size Merkle tree
	tree := merkle.NewFixedSizeMerkleTree(leaf1, leaf2, leaf3, leaf4)

	fmt.Println("FixedSizeMerkleTree:")
	fmt.Printf("  Number of leaves: %d\n", len(tree.Leaves))
	fmt.Printf("  Root: %s\n", tree.Root.String())
	fmt.Printf("  Number of branch levels: %d\n", len(tree.Branches))

	// Generate proof for leaf2
	proof, err := tree.Proof(leaf2)
	if err != nil {
		fmt.Printf("  Error generating proof: %v\n", err)
	} else {
		fmt.Printf("  Proof for leaf 20: %d elements\n", len(proof))
		for i, p := range proof {
			fmt.Printf("    Proof[%d]: %s\n", i, p.String())
		}
	}
}
```

## Common Use Cases

- Create trees for proving that specific values are part of a committed dataset such as allowlists or whitelists. See [Verifying Multiple Leaves example](/docs/merkle/examples#verifying-multiple-leaves).
- Generate compact cryptographic commitments to large state that can be efficiently verified. See [Basic Tree Creation example](/docs/merkle/examples#basic-merkle-tree-creation-and-verification).
- Build trees for verifying specific elements of a dataset without downloading all the data.
- Create Merkle roots for transaction batches or state snapshots in blockchain applications. See [Large Tree example](/docs/merkle/examples#large-tree-with-proof-size-analysis).
- Handle datasets with odd numbers of elements by automatically pairing the last leaf with zero. See [Handling Odd Number of Leaves example](/docs/merkle/examples#handling-odd-number-of-leaves).

