# ProofMerklePath

Verifies if a leaf node is part of a Merkle tree by checking the validity of a Merkle path. This function recursively validates the path from a leaf to the root, ensuring data integrity without requiring the entire tree. The proof verification works by hashing the leaf with sibling nodes at each level and comparing the final computed hash with the expected root.

## Function Signature

```go
func ProofMerklePath(root, leaf *big.Int, path []*big.Int) bool
```

**Source:** [merkle.go:L154-L161](https://github.com/NethermindEth/starknet.go/blob/main/merkle/merkle.go#L154-L161)

## Parameters

- `root` (*big.Int): The root node hash of the Merkle tree
- `leaf` (*big.Int): The leaf node value to verify
- `path` ([]*big.Int): A slice of sibling hashes from the leaf to the root

## Returns

- `bool`: Returns `true` if the leaf is part of the Merkle tree path, `false` otherwise

## How It Works

The function recursively traverses the path from the leaf to the root, verifying each node against the expected hash value:

1. **Base Case**: If the path is empty (length 0), compare the leaf directly with the root
2. **Recursive Step**: Hash the current leaf with the first element in the path using `MerkleHash`
3. **Continue Traversal**: Recursively call `ProofMerklePath` with the computed hash as the new leaf and remaining path
4. **Validation**: If the final computed hash matches the root, the proof is valid and returns `true`

## Usage Example

```go
package main

import (
	"fmt"
	"math/big"

	"github.com/NethermindEth/starknet.go/merkle"
)

func main() {
	// Create a simple Merkle tree structure
	leaf1 := big.NewInt(1)
	leaf2 := big.NewInt(2)
	leaf3 := big.NewInt(3)
	leaf4 := big.NewInt(4)

	// Build a simple tree
	hash12 := merkle.MerkleHash(leaf1, leaf2)
	hash34 := merkle.MerkleHash(leaf3, leaf4)
	root := merkle.MerkleHash(hash12, hash34)

	// Create proof path for leaf1
	// Path: [leaf2, hash34] to reach root
	path := []*big.Int{leaf2, hash34}

	// Verify the proof
	isValid := merkle.ProofMerklePath(root, leaf1, path)

	fmt.Println("ProofMerklePath:")
	fmt.Printf("  Root: %s\n", root.String())
	fmt.Printf("  Leaf: %s\n", leaf1.String())
	fmt.Printf("  Path length: %d\n", len(path))
	fmt.Printf("  Proof valid: %v\n", isValid)
}
```

## Error Handling

```go
// ProofMerklePath returns bool, check the result to handle invalid proofs
if !merkle.ProofMerklePath(root, leaf, proof) {
	// Proof is invalid - leaf is not in the tree or proof is corrupted
	fmt.Println("Invalid Merkle proof")
	return
}

// Proof is valid, proceed with confidence that leaf is in the tree
fmt.Println("Proof verified successfully")
```

## Common Use Cases

- Verify that a piece of data is included in a larger dataset without downloading the entire dataset. See [Basic Tree Creation and Verification example](/docs/merkle/examples#basic-merkle-tree-creation-and-verification).
- Prove the value of a contract storage slot at a specific block height without requiring the full state. See [Manual Tree Construction example](/docs/merkle/examples#manual-merkle-tree-construction).
- Efficiently test if an element belongs to a set represented by a Merkle tree. See [Detecting Invalid Proofs example](/docs/merkle/examples#detecting-invalid-proofs).
- Enable light clients to verify transactions or state without storing the complete blockchain.

