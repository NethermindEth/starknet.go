# SubscribeNewTransactionReceipts

Subscribe to new transaction receipts via WebSocket stream.

import { Callout } from 'vocs/components'

<Callout type="warning">
  **Provider Support**: This WebSocket method may not be supported by all RPC providers. Some providers (like Alchemy) currently do not support transaction receipt subscriptions. Check your provider's documentation for WebSocket method availability.
</Callout>

## Method Signature

```go
func (ws *WsProvider) SubscribeNewTransactionReceipts(
    ctx context.Context,
    txnReceipts chan<- *TransactionReceiptWithBlockInfo,
    options *SubNewTxnReceiptsInput,
) (*client.ClientSubscription, error)
```

## Parameters

- `ctx` - The context.Context object for controlling the function call
- `txnReceipts` - The channel to send new transaction receipts to
- `options` - Optional input struct containing transaction filters. Set to nil if no filters are needed

## Returns

- `*client.ClientSubscription` - The client subscription object, used to unsubscribe from the stream and to get errors
- `error` - An error, if any

## Description

SubscribeNewTransactionReceipts creates a WebSocket stream that fires events when new transaction receipts are generated on Starknet. This provides real-time information about transaction execution, including success/failure status, events emitted, and gas consumption.

You can optionally filter receipts by sender address to monitor transactions from specific accounts.

The subscription will continue to send receipts until unsubscribed or the connection is closed.

## Usage Example

```go
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/rpc"
)

func main() {
	// Connect to WebSocket endpoint
	wsProvider, err := rpc.NewProvider("wss://starknet-sepolia.public.blastapi.io/rpc/v0_7")
	if err != nil {
		log.Fatal(err)
	}

	ctx := context.Background()

	// Create channel to receive transaction receipts
	receiptsChan := make(chan *rpc.TransactionReceiptWithBlockInfo)

	// Subscribe to receipts from a specific sender address
	senderAddress, _ := new(felt.Felt).SetString("0x1234567890abcdef...")
	options := &rpc.SubNewTxnReceiptsInput{
		SenderAddress: []*felt.Felt{senderAddress},
	}

	sub, err := wsProvider.SubscribeNewTransactionReceipts(ctx, receiptsChan, options)
	if err != nil {
		log.Fatal("Failed to subscribe:", err)
	}
	defer sub.Unsubscribe()

	fmt.Println("Subscribed to transaction receipts...")

	// Listen for new receipts
	for {
		select {
		case receipt := <-receiptsChan:
			fmt.Printf("New Transaction Receipt:\n")
			fmt.Printf("  Transaction Hash: %s\n", receipt.TransactionHash)
			fmt.Printf("  Block Number: %d\n", receipt.BlockNumber)
			fmt.Printf("  Status: %s\n", receipt.ExecutionStatus)
			fmt.Printf("  Events: %d\n", len(receipt.Events))

			// Check if transaction succeeded
			if receipt.ExecutionStatus == "SUCCEEDED" {
				fmt.Println("  ✅ Transaction succeeded")
			} else {
				fmt.Printf("  ❌ Transaction failed: %s\n", receipt.RevertReason)
			}
		case err := <-sub.Err():
			log.Fatal("Subscription error:", err)
		case <-time.After(60 * time.Second):
			fmt.Println("No receipts received in 60s, exiting...")
			return
		}
	}
}
```

## Filter Options

The `SubNewTxnReceiptsInput` struct allows filtering by sender address:

```go
type SubNewTxnReceiptsInput struct {
	SenderAddress []*felt.Felt  // Filter by transaction sender addresses
}
```

**Examples:**

```go
// Subscribe to all transaction receipts
wsProvider.SubscribeNewTransactionReceipts(ctx, receiptsChan, nil)

// Subscribe to receipts from specific sender
options := &rpc.SubNewTxnReceiptsInput{
	SenderAddress: []*felt.Felt{senderAddr},
}

// Subscribe to receipts from multiple senders
options := &rpc.SubNewTxnReceiptsInput{
	SenderAddress: []*felt.Felt{addr1, addr2, addr3},
}
```

## Receipt Information

The `TransactionReceiptWithBlockInfo` contains:

- **Transaction Hash** - Unique identifier for the transaction
- **Block Number** - Block containing the transaction
- **Execution Status** - "SUCCEEDED" or "REVERTED"
- **Events** - Events emitted during execution
- **Actual Fee** - Gas consumed in Wei
- **Revert Reason** - Error message if transaction failed
- **Messages Sent** - L2→L1 messages sent

## Common Use Cases

1. **Transaction Monitoring**: Track status of submitted transactions
2. **Account Activity**: Monitor all transactions from specific accounts
3. **Automated Workflows**: Trigger actions when transactions complete
4. **Error Tracking**: Log and analyze failed transactions
5. **Gas Analytics**: Monitor gas consumption patterns

## Error Handling

```go
sub, err := wsProvider.SubscribeNewTransactionReceipts(ctx, receiptsChan, options)
if err != nil {
	// Handle subscription errors
	log.Fatal("Failed to subscribe:", err)
}

// Listen for stream errors
go func() {
	err := <-sub.Err()
	if err != nil {
		log.Printf("Stream error: %v", err)
	}
}()
```

## Possible Errors

- `ErrTooManyAddressesInFilter` - Too many sender addresses in the filter
- Connection errors - WebSocket connection issues

## Related Methods

- [SubscribeEvents](./subscribe-events) - Subscribe to contract events
- [SubscribeNewTransactions](./subscribe-new-transactions) - Subscribe to new transactions
- [SubscribeTransactionStatus](./subscribe-transaction-status) - Subscribe to transaction status updates
- [TransactionReceipt](../methods/transaction-receipt) - Query receipt by hash (non-streaming)

## Specification

Follows the Starknet WebSocket RPC specification for `starknet_subscribeNewTransactionReceipts`.
