# SubscribeNewTransactionReceipts

Creates a WebSocket stream which fires events when new transaction receipts are created on Starknet. The endpoint receives optional filters including finality statuses and sender addresses. An event is fired for each finality status update. It is possible for receipts for pre-confirmed transactions to be received multiple times, or not at all.

import { Callout } from 'vocs/components'

<Callout type="warning">
  **Provider Support**: This WebSocket method may not be supported by all RPC providers. Some providers may have limited support for WebSocket subscriptions. Check your provider's documentation for WebSocket method availability, or consider [running your own Juno node](https://www.youtube.com/watch?v=gvdC2XIOibA) for full WebSocket support.
</Callout>

## Method Signature

```go
func (ws *WsProvider) SubscribeNewTransactionReceipts(
	ctx context.Context,
	txnReceipts chan<- *TransactionReceiptWithBlockInfo,
	options *SubNewTxnReceiptsInput,
) (*client.ClientSubscription, error)
```

**Source:** [websocket.go:L101-L118](https://github.com/NethermindEth/starknet.go/blob/main/rpc/websocket.go#L101-L118)

## Parameters

- `ctx` (context.Context): The context for controlling the function call
- `txnReceipts` (chan&lt;- \*TransactionReceiptWithBlockInfo): The channel to send the new transaction receipts to
- `options` (\*SubNewTxnReceiptsInput): The optional input struct containing the optional filters. Set to nil if no filters are needed

## Returns

- `*client.ClientSubscription`: The client subscription object, used to unsubscribe from the stream and to get errors
- `error`: An error if any occurred (`ErrTooManyAddressesInFilter`)

## Type Definitions

### SubNewTxnReceiptsInput

The optional input struct containing filters for transaction receipt subscriptions.

```go
type SubNewTxnReceiptsInput struct {
	// (Optional) A vector of finality statuses to receive updates for.
	// Only `PRE_CONFIRMED` and `ACCEPTED_ON_L2` are supported. Default is `ACCEPTED_ON_L2`.
	FinalityStatus []TxnFinalityStatus `json:"finality_status,omitempty"`
	// (Optional) Filter transaction receipts to only include transactions
	// sent by the specified addresses
	SenderAddress []*felt.Felt `json:"sender_address,omitempty"`
}
```

**Source:** [types_transaction.go:L342-L350](https://github.com/NethermindEth/starknet.go/blob/main/rpc/types_transaction.go#L342-L350)

### TransactionReceiptWithBlockInfo

The transaction receipt notification received from the server, including block information.

```go
type TransactionReceiptWithBlockInfo struct {
	TransactionReceipt
	BlockHash   *felt.Felt `json:"block_hash,omitempty"`
	BlockNumber uint       `json:"block_number,omitempty"`
}
```

**Source:** [types_transaction_receipt.go:L245-L249](https://github.com/NethermindEth/starknet.go/blob/main/rpc/types_transaction_receipt.go#L245-L249)

## Usage Example

```go
package main

import (
	"context"
	"fmt"
	"log"
	"os"
	"time"

	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/joho/godotenv"
)

func main() {
	// Load environment variables
	err := godotenv.Load()
	if err != nil {
		log.Fatal("Error loading .env file")
	}

	wsURL := os.Getenv("STARKNET_WS_URL")
	if wsURL == "" {
		log.Fatal("STARKNET_WS_URL not found in .env file")
	}

	ctx := context.Background()

	// Connect to WebSocket endpoint
	wsProvider, err := rpc.NewWebsocketProvider(ctx, wsURL)
	if err != nil {
		log.Fatal("Failed to connect:", err)
	}
	defer wsProvider.Close()

	// Create channel to receive transaction receipts
	receiptsChan := make(chan *rpc.TransactionReceiptWithBlockInfo)

	// Subscribe to all transaction receipts (no filter)
	sub, err := wsProvider.SubscribeNewTransactionReceipts(ctx, receiptsChan, &rpc.SubNewTxnReceiptsInput{})
	if err != nil {
		log.Fatal("Failed to subscribe:", err)
	}
	defer sub.Unsubscribe()

	fmt.Println("Successfully subscribed to transaction receipts")
	fmt.Println("Monitoring transaction receipts on the network...\n")

	// Listen for receipts with timeout
	timeout := time.After(60 * time.Second)
	receiptCount := 0

	for {
		select {
		case receipt := <-receiptsChan:
			receiptCount++
			fmt.Printf("Receipt #%d:\n", receiptCount)
			fmt.Printf("  Block Number: %d\n", receipt.BlockNumber)
			fmt.Printf("  Block Hash: %s\n", receipt.BlockHash)
			fmt.Printf("  Type: %T\n\n", receipt.TransactionReceipt)

			if receiptCount >= 3 {
				fmt.Printf("Successfully received %d receipts\n", receiptCount)
				return
			}
		case err := <-sub.Err():
			log.Fatal("Subscription error:", err)
		case <-timeout:
			if receiptCount > 0 {
				fmt.Printf("Test completed - received %d receipt(s)\n", receiptCount)
			} else {
				fmt.Println("Timeout - no receipts received in 60s (this is normal if network is quiet)")
			}
			return
		}
	}
}
```

:::note
Create a `.env` file in your project root with `STARKNET_WS_URL` and install the godotenv package to run the code snippet.
:::

## Error Handling

```go
sub, err := wsProvider.SubscribeNewTransactionReceipts(ctx, receiptsChan, &rpc.SubNewTxnReceiptsInput{})
if err != nil {
	switch {
	case errors.Is(err, rpc.ErrTooManyAddressesInFilter):
		log.Println("Too many sender addresses in the filter")
		return
	default:
		log.Printf("Subscription error: %v", err)
		return
	}
}

// Listen for stream errors
go func() {
	err := <-sub.Err()
	if err != nil {
		log.Printf("Stream error: %v", err)
	}
}()
```

## Common Use Cases

- Tracking status of submitted transactions in real-time, including success/failure.
- Monitoring all transaction receipts from specific accounts by filtering on sender addresses.
- Triggering actions when transactions complete, such as sending notifications or initiating follow-up transactions.

