# SubscribeNewHeads

Creates a WebSocket stream which fires events for new block headers produced on Starknet. The stream sends headers for all blocks from the specified starting block up to the latest block, and continues to send new block headers as they are produced.

import { Callout } from 'vocs/components'

<Callout type="info">
  **Provider Support**: This WebSocket method may not be supported by all RPC providers. Some providers may have limited support for WebSocket subscriptions. Check your provider's documentation for WebSocket method availability, or consider [running your own Juno node](https://www.youtube.com/watch?v=gvdC2XIOibA) for full WebSocket support.
</Callout>

## Method Signature

```go
func (ws *WsProvider) SubscribeNewHeads(
	ctx context.Context,
	headers chan<- *BlockHeader,
	subBlockID SubscriptionBlockID,
) (*client.ClientSubscription, error)
```

**Source:** [websocket.go:L60-L82](https://github.com/NethermindEth/starknet.go/blob/main/rpc/websocket.go#L60-L82)

## Parameters

- `ctx` (context.Context): The context for controlling the function call
- `headers` (chan&lt;- \*BlockHeader): The channel to send new block headers to
- `subBlockID` (SubscriptionBlockID): Optional starting block ID. Pass empty struct `SubscriptionBlockID{}` to subscribe from latest block (limited to 1024 blocks back)

## Returns

- `*client.ClientSubscription`: The client subscription object, used to unsubscribe from the stream and to get errors
- `error`: An error if any occurred (`ErrTooManyBlocksBack`, `ErrBlockNotFound`)

## Type Definitions

### SubscriptionBlockID

The block ID for specifying the starting block for the subscription.

```go
type SubscriptionBlockID struct {
	Number *uint64    `json:"block_number,omitempty"`
	Hash   *felt.Felt `json:"block_hash,omitempty"`
	Tag    string     `json:",omitempty"`
}
```

**Source:** [types_block.go:L142](https://github.com/NethermindEth/starknet.go/blob/main/rpc/types_block.go#L142)

### BlockHeader

The block header notification received from the server.

```go
type BlockHeader struct {
	// Hash The hash of this block
	Hash *felt.Felt `json:"block_hash"`
	// ParentHash The hash of this block's parent
	ParentHash *felt.Felt `json:"parent_hash"`
	// Number the block number (its height)
	Number uint64 `json:"block_number"`
	// NewRoot The new global state root
	NewRoot *felt.Felt `json:"new_root"`
	// Timestamp the time in which the block was created, encoded in Unix time
	Timestamp uint64 `json:"timestamp"`
	// SequencerAddress the StarkNet identity of the sequencer submitting this block
	SequencerAddress *felt.Felt `json:"sequencer_address"`
	// The price of l1 gas in the block
	L1GasPrice ResourcePrice `json:"l1_gas_price"`
	// The price of l2 gas in the block
	L2GasPrice ResourcePrice `json:"l2_gas_price"`
	// The price of l1 data gas in the block
	L1DataGasPrice ResourcePrice `json:"l1_data_gas_price"`
	// Specifies whether the data of this block is published via blob data or calldata
	L1DAMode L1DAMode `json:"l1_da_mode"`
	// Semver of the current Starknet protocol
	StarknetVersion string `json:"starknet_version"`
}
```

**Source:** [types_block.go:L63-L85](https://github.com/NethermindEth/starknet.go/blob/main/rpc/types_block.go#L63-L85)

## Usage Example

```go
package main

import (
	"context"
	"fmt"
	"log"
	"os"
	"time"

	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/joho/godotenv"
)

func main() {
	// Load environment variables
	err := godotenv.Load()
	if err != nil {
		log.Fatal("Error loading .env file")
	}

	wsURL := os.Getenv("STARKNET_WS_URL")
	if wsURL == "" {
		log.Fatal("STARKNET_WS_URL not found in .env file")
	}

	ctx := context.Background()

	// Connect to WebSocket endpoint
	wsProvider, err := rpc.NewWebsocketProvider(ctx, wsURL)
	if err != nil {
		log.Fatal("Failed to connect:", err)
	}
	defer wsProvider.Close()

	// Create channel to receive block headers
	headersChan := make(chan *rpc.BlockHeader)

	// Subscribe from latest block
	sub, err := wsProvider.SubscribeNewHeads(ctx, headersChan, rpc.SubscriptionBlockID{Tag: "latest"})
	if err != nil {
		log.Fatal("Failed to subscribe:", err)
	}
	defer sub.Unsubscribe()

	fmt.Println("Successfully subscribed to new block headers")
	fmt.Println("Waiting for new blocks...\n")

	// Listen for new blocks with timeout
	timeout := time.After(120 * time.Second)
	blockCount := 0

	for {
		select {
		case header := <-headersChan:
			blockCount++
			fmt.Printf("Block #%d:\n", blockCount)
			fmt.Printf("  Block Number: %d\n", header.Number)
			fmt.Printf("  Block Hash: %s\n", header.Hash)
			fmt.Printf("  Timestamp: %d\n", header.Timestamp)
			fmt.Printf("  Sequencer: %s\n", header.SequencerAddress)
			fmt.Printf("  Parent Hash: %s\n\n", header.ParentHash)

			if blockCount >= 2 {
				fmt.Printf("Successfully received %d blocks\n", blockCount)
				return
			}
		case err := <-sub.Err():
			log.Fatal("Subscription error:", err)
		case <-timeout:
			if blockCount > 0 {
				fmt.Printf("Test completed - received %d block(s)\n", blockCount)
			} else {
				fmt.Println("Timeout - no blocks received in 120s")
			}
			return
		}
	}
}
```

:::note
Create a `.env` file in your project root with `STARKNET_WS_URL` and install the godotenv package to run the code snippet.
:::

## Error Handling

```go
sub, err := wsProvider.SubscribeNewHeads(ctx, headersChan, rpc.SubscriptionBlockID{Tag: "latest"})
if err != nil {
	switch {
	case errors.Is(err, rpc.ErrTooManyBlocksBack):
		log.Println("Requested starting block is too far in the past (>1024 blocks)")
		return
	case errors.Is(err, rpc.ErrBlockNotFound):
		log.Println("Specified starting block does not exist")
		return
	default:
		log.Printf("Subscription error: %v", err)
		return
	}
}

// Listen for stream errors
go func() {
	err := <-sub.Err()
	if err != nil {
		log.Printf("Stream error: %v", err)
	}
}()
```

## Common Use Cases

- **Monitor Chain Progression**: Track new blocks as they're produced on Starknet in real-time
- **Block Explorer Applications**: Update UI with latest block information and metadata
- **Transaction Confirmation Tracking**: Wait for specific block confirmations before considering transactions final
- **Network Health Monitoring**: Monitor block production rate, timing, and sequencer activity

## Related Methods

- [SubscribeEvents](/docs/rpc/websocket/subscribe-events) - Subscribe to contract events
- [SubscribeNewTransactions](/docs/rpc/websocket/subscribe-new-transactions) - Subscribe to new transactions
- [BlockWithTxHashes](/docs/rpc/methods/block-with-tx-hashes) - Get specific block data (non-streaming)
