# SubscribeNewTransactions

Creates a WebSocket stream which fires events when new transactions are created on Starknet. The endpoint receives optional filters including finality statuses and sender addresses. An event is fired for each finality status update. It is possible for events for pre-confirmed and candidate transactions to be received multiple times, or not at all.

import { Callout } from 'vocs/components'

<Callout type="warning">
  **Provider Support**: This WebSocket method may not be supported by all RPC providers. Some providers may have limited support for WebSocket subscriptions. Check your provider's documentation for WebSocket method availability, or consider [running your own Juno node](https://www.youtube.com/watch?v=gvdC2XIOibA) for full WebSocket support.
</Callout>

## Method Signature

```go
func (ws *WsProvider) SubscribeNewTransactions(
	ctx context.Context,
	newTxns chan<- *TxnWithHashAndStatus,
	options *SubNewTxnsInput,
) (*client.ClientSubscription, error)
```

**Source:** [websocket.go:L136-L147](https://github.com/NethermindEth/starknet.go/blob/main/rpc/websocket.go#L136-L147)

## Parameters

- `ctx` (context.Context): The context for controlling the function call
- `newTxns` (chan&lt;- \*TxnWithHashAndStatus): The channel to send the new transactions to
- `options` (\*SubNewTxnsInput): The optional input struct containing the optional filters. Set to nil if no filters are needed

## Returns

- `*client.ClientSubscription`: The client subscription object, used to unsubscribe from the stream and to get errors
- `error`: An error if any occurred (`ErrTooManyAddressesInFilter`)

## Type Definitions

### SubNewTxnsInput

The optional input struct containing filters for new transaction subscriptions.

```go
type SubNewTxnsInput struct {
	// (Optional) A vector of finality statuses to receive updates for.
	// Support all transaction statuses, except `ACCEPTED_ON_L1`. Default is `ACCEPTED_ON_L2`.
	FinalityStatus []TxnStatus `json:"finality_status,omitempty"`
	// (Optional) Filter transaction receipts to only include transactions sent
	// by the specified addresses
	SenderAddress []*felt.Felt `json:"sender_address,omitempty"`
}
```

**Source:** [types_transaction.go:L354-L362](https://github.com/NethermindEth/starknet.go/blob/main/rpc/types_transaction.go#L354-L362)

### TxnWithHashAndStatus

The transaction notification received from the server, including finality status.

```go
type TxnWithHashAndStatus struct {
	// Transaction with hash and status
	BlockTransaction
	// Finality status of the transaction, except `ACCEPTED_ON_L1`.
	FinalityStatus TxnStatus `json:"finality_status"`
}
```

**Source:** [types_transaction.go:L366-L371](https://github.com/NethermindEth/starknet.go/blob/main/rpc/types_transaction.go#L366-L371)

## Usage Example

```go
package main

import (
	"context"
	"fmt"
	"log"
	"os"
	"time"

	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/joho/godotenv"
)

func main() {
	// Load environment variables
	err := godotenv.Load()
	if err != nil {
		log.Fatal("Error loading .env file")
	}

	wsURL := os.Getenv("STARKNET_WS_URL")
	if wsURL == "" {
		log.Fatal("STARKNET_WS_URL not found in .env file")
	}

	ctx := context.Background()

	// Connect to WebSocket endpoint
	wsProvider, err := rpc.NewWebsocketProvider(ctx, wsURL)
	if err != nil {
		log.Fatal("Failed to connect:", err)
	}
	defer wsProvider.Close()

	// Create channel to receive new transactions
	txnsChan := make(chan *rpc.TxnWithHashAndStatus)

	// Subscribe to all new transactions (no filter)
	sub, err := wsProvider.SubscribeNewTransactions(ctx, txnsChan, &rpc.SubNewTxnsInput{})
	if err != nil {
		log.Fatal("Failed to subscribe:", err)
	}
	defer sub.Unsubscribe()

	fmt.Println("Successfully subscribed to new transactions")
	fmt.Println("Monitoring new transactions on the network...\n")

	// Listen for new transactions with timeout
	timeout := time.After(60 * time.Second)
	txnCount := 0

	for {
		select {
		case txn := <-txnsChan:
			txnCount++
			fmt.Printf("Transaction #%d:\n", txnCount)
			fmt.Printf("  Finality Status: %s\n", txn.FinalityStatus)
			fmt.Printf("  Type: %T\n\n", txn.BlockTransaction)

			if txnCount >= 3 {
				fmt.Printf("Successfully received %d transactions\n", txnCount)
				return
			}
		case err := <-sub.Err():
			log.Fatal("Subscription error:", err)
		case <-timeout:
			if txnCount > 0 {
				fmt.Printf("Test completed - received %d transaction(s)\n", txnCount)
			} else {
				fmt.Println("Timeout - no transactions received in 60s (this is normal if network is quiet)")
			}
			return
		}
	}
}
```

:::note
Create a `.env` file in your project root with `STARKNET_WS_URL` and install the godotenv package to run the code snippet.
:::

## Error Handling

```go
sub, err := wsProvider.SubscribeNewTransactions(ctx, txnsChan, &rpc.SubNewTxnsInput{})
if err != nil {
	switch {
	case errors.Is(err, rpc.ErrTooManyAddressesInFilter):
		log.Println("Too many sender addresses in the filter")
		return
	default:
		log.Printf("Subscription error: %v", err)
		return
	}
}

// Listen for stream errors
go func() {
	err := <-sub.Err()
	if err != nil {
		log.Printf("Stream error: %v", err)
	}
}()
```

## Common Use Cases

- Tracking pending transactions in real-time before they are included in blocks.
- Monitoring all transactions from specific accounts by filtering on sender addresses.
- Collecting and analyze transaction patterns and network activity.
- Monitoring network activity, transaction volume, and transaction types.

