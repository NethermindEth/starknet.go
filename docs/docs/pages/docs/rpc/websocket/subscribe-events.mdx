# SubscribeEvents

Creates a WebSocket stream which fires events for new Starknet events with applied filters. Events are emitted for all events from the specified block_id up to the latest block. If `PRE_CONFIRMED` finality status is provided, events might appear multiple times for each finality status update. If a single event is required, `ACCEPTED_ON_L2` must be selected (the default).

import { Callout } from 'vocs/components'

<Callout type="info">
  **Provider Support**: This WebSocket method may not be supported by all RPC providers. Some providers may have limited support for WebSocket subscriptions. Check your provider's documentation for WebSocket method availability, or consider [running your own Juno node](https://www.youtube.com/watch?v=gvdC2XIOibA) for full WebSocket support.
</Callout>

## Method Signature

```go
func (ws *WsProvider) SubscribeEvents(
	ctx context.Context,
	events chan<- *EmittedEventWithFinalityStatus,
	options *EventSubscriptionInput,
) (*client.ClientSubscription, error)
```

**Source:** [websocket.go:L29-L45](https://github.com/NethermindEth/starknet.go/blob/main/rpc/websocket.go#L29-L45)

## Parameters

- `ctx` (context.Context): The context for controlling the function call
- `events` (chan&lt;- \*EmittedEventWithFinalityStatus): The channel to send the new events to
- `options` (\*EventSubscriptionInput): The optional input struct containing the optional filters. Set to nil if no filters are needed

## Returns

- `*client.ClientSubscription`: The client subscription object, used to unsubscribe from the stream and to get errors
- `error`: An error if any occurred (`ErrTooManyKeysInFilter`, `ErrTooManyBlocksBack`, `ErrBlockNotFound`)

## Type Definitions

### EventSubscriptionInput

The optional input struct containing filters for event subscriptions.

```go
type EventSubscriptionInput struct {
	// (Optional) Filter events by from_address which emitted the event
	FromAddress *felt.Felt `json:"from_address,omitempty"`
	// (Optional) Per key (by position), designate the possible values to be
	// matched for events to be returned. Empty array designates 'any' value
	Keys [][]*felt.Felt `json:"keys,omitempty"`
	// (Optional) The block to get notifications from, default is latest, limited
	// to 1024 blocks back
	SubBlockID SubscriptionBlockID `json:"block_id,omitzero"`
	// (Optional) The finality status of the most recent events to include.
	// Only `PRE_CONFIRMED` and `ACCEPTED_ON_L2` are supported. Default is `ACCEPTED_ON_L2`.
	// If PRE_CONFIRMED finality is selected, events might appear multiple times,
	// once for each finality status update.
	FinalityStatus TxnFinalityStatus `json:"finality_status,omitempty"`
}
```

**Source:** [types_event.go:L57-L71](https://github.com/NethermindEth/starknet.go/blob/main/rpc/types_event.go#L57-L71)

### EmittedEventWithFinalityStatus

Notification from the server about a new event. The event also includes the finality status of the transaction emitting the event.

```go
type EmittedEventWithFinalityStatus struct {
	EmittedEvent
	FinalityStatus TxnFinalityStatus `json:"finality_status"`
}
```

**Source:** [types_event.go:L76-L79](https://github.com/NethermindEth/starknet.go/blob/main/rpc/types_event.go#L76-L79)

## Usage Example

```go
package main

import (
	"context"
	"fmt"
	"log"
	"os"
	"time"

	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/joho/godotenv"
)

func main() {
	// Load environment variables
	err := godotenv.Load()
	if err != nil {
		log.Fatal("Error loading .env file")
	}

	wsURL := os.Getenv("STARKNET_WS_URL")
	if wsURL == "" {
		log.Fatal("STARKNET_WS_URL not found in .env file")
	}

	ctx := context.Background()

	// Connect to WebSocket endpoint
	wsProvider, err := rpc.NewWebsocketProvider(ctx, wsURL)
	if err != nil {
		log.Fatal("Failed to connect:", err)
	}
	defer wsProvider.Close()

	// Create channel to receive events
	eventsChan := make(chan *rpc.EmittedEventWithFinalityStatus)

	// Subscribe to all events (empty filter to get all events)
	options := &rpc.EventSubscriptionInput{}
	sub, err := wsProvider.SubscribeEvents(ctx, eventsChan, options)
	if err != nil {
		log.Fatal("Failed to subscribe:", err)
	}
	defer sub.Unsubscribe()

	fmt.Println("Successfully subscribed to events")
	fmt.Println("Monitoring all events on the network...")

	// Listen for events with timeout
	timeout := time.After(45 * time.Second)
	eventCount := 0

	for {
		select {
		case event := <-eventsChan:
			eventCount++
			fmt.Printf("Event #%d received:\n", eventCount)
			fmt.Printf("  Block Number: %d\n", event.BlockNumber)
			fmt.Printf("  Transaction Hash: %s\n", event.TransactionHash)
			fmt.Printf("  From Address: %s\n", event.FromAddress)
			fmt.Printf("  Keys: %d\n", len(event.Keys))
			fmt.Printf("  Data: %d items\n", len(event.Data))
			fmt.Printf("  Finality: %s\n\n", event.FinalityStatus)

			if eventCount >= 3 {
				fmt.Printf("Successfully received %d events\n", eventCount)
				return
			}
		case err := <-sub.Err():
			log.Fatal("Subscription error:", err)
		case <-timeout:
			if eventCount > 0 {
				fmt.Printf("Test completed - received %d event(s)\n", eventCount)
			} else {
				fmt.Println("Timeout - no events received in 45s (this is normal if network is quiet)")
			}
			return
		}
	}
}
```

:::note
Create a `.env` file in your project root with `STARKNET_WS_URL` and install the godotenv package to run the code snippet.
:::

## Error Handling

```go
sub, err := wsProvider.SubscribeEvents(ctx, eventsChan, options)
if err != nil {
	switch {
	case errors.Is(err, rpc.ErrTooManyKeysInFilter):
		log.Println("Too many keys in the event filter")
		return
	case errors.Is(err, rpc.ErrTooManyBlocksBack):
		log.Println("Requested block is too far in the past (>1024 blocks)")
		return
	case errors.Is(err, rpc.ErrBlockNotFound):
		log.Println("Specified block does not exist")
		return
	default:
		log.Printf("Subscription error: %v", err)
		return
	}
}

// Listen for stream errors
go func() {
	err := <-sub.Err()
	if err != nil {
		log.Printf("Stream error: %v", err)
	}
}()
```

## Common Use Cases

- **Monitor Token Transfers**: Subscribe to Transfer events from specific tokens to track token movements in real-time
- **Track Contract Events**: Listen to specific contract interactions and state changes as they happen on-chain
- **Real-time Updates**: Get immediate notifications of on-chain events without polling
- **Event Aggregation**: Collect and process events from multiple contracts simultaneously

## Related Methods

- [SubscribeNewHeads](/docs/rpc/websocket/subscribe-new-heads) - Subscribe to new block headers
- [SubscribeNewTransactions](/docs/rpc/websocket/subscribe-new-transactions) - Subscribe to new transactions
- [Events](/docs/rpc/methods/events) - Query historical events (non-streaming)
