# SubscribeTransactionStatus

Subscribe to transaction status updates via WebSocket stream.

import { Callout } from 'vocs/components'

<Callout type="warning">
  **Provider Support**: This WebSocket method may not be supported by all RPC providers. Some providers may have limited support for transaction status subscriptions. Check your provider's documentation for WebSocket method availability.
</Callout>

## Method Signature

```go
func (ws *WsProvider) SubscribeTransactionStatus(
    ctx context.Context,
    newStatus chan<- *NewTxnStatus,
    transactionHash *felt.Felt,
) (*client.ClientSubscription, error)
```

## Parameters

- `ctx` - The context.Context object for controlling the function call
- `newStatus` - The channel to send transaction status updates to
- `transactionHash` - The hash of the transaction to monitor

## Returns

- `*client.ClientSubscription` - The client subscription object, used to unsubscribe from the stream and to get errors
- `error` - An error, if any

## Description

SubscribeTransactionStatus creates a WebSocket stream that monitors a specific transaction's status changes. The stream first fires an event with the current known status, then continues to send updates as the transaction progresses through different states (received → pending → accepted → finalized).

This is particularly useful for waiting for transaction confirmations and tracking transaction lifecycle.

The subscription will continue to send status updates until the transaction is finalized, unsubscribed, or the connection is closed.

## Usage Example

```go
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/rpc"
)

func main() {
	// Connect to WebSocket endpoint
	wsProvider, err := rpc.NewProvider("wss://starknet-sepolia.public.blastapi.io/rpc/v0_7")
	if err != nil {
		log.Fatal(err)
	}

	ctx := context.Background()

	// Transaction hash to monitor
	txHash, _ := new(felt.Felt).SetString("0x1234567890abcdef...")

	// Create channel to receive status updates
	statusChan := make(chan *rpc.NewTxnStatus)

	// Subscribe to transaction status updates
	sub, err := wsProvider.SubscribeTransactionStatus(ctx, statusChan, txHash)
	if err != nil {
		log.Fatal("Failed to subscribe:", err)
	}
	defer sub.Unsubscribe()

	fmt.Printf("Monitoring transaction: %s\n", txHash)

	// Listen for status updates
	for {
		select {
		case status := <-statusChan:
			fmt.Printf("\nStatus Update:\n")
			fmt.Printf("  Transaction Hash: %s\n", status.TransactionHash)
			fmt.Printf("  Execution Status: %s\n", status.ExecutionStatus)
			fmt.Printf("  Finality Status: %s\n", status.FinalityStatus)

			// Check if transaction is finalized
			if status.FinalityStatus == "ACCEPTED_ON_L1" ||
			   status.FinalityStatus == "ACCEPTED_ON_L2" {
				fmt.Println("✅ Transaction finalized!")

				if status.ExecutionStatus == "SUCCEEDED" {
					fmt.Println("✅ Transaction executed successfully")
				} else if status.ExecutionStatus == "REVERTED" {
					fmt.Printf("❌ Transaction reverted: %s\n", status.RevertReason)
				}
				return
			}
		case err := <-sub.Err():
			log.Fatal("Subscription error:", err)
		case <-time.After(5 * time.Minute):
			fmt.Println("Timeout waiting for finalization")
			return
		}
	}
}
```

## Status Information

The `NewTxnStatus` struct contains:

- **TransactionHash** - Hash of the monitored transaction
- **ExecutionStatus** - Execution outcome: "SUCCEEDED" or "REVERTED"
- **FinalityStatus** - Finality state: "RECEIVED", "ACCEPTED_ON_L2", or "ACCEPTED_ON_L1"
- **RevertReason** - Error message if transaction reverted

## Transaction Status Flow

A transaction typically progresses through these states:

1. **RECEIVED** - Transaction received by sequencer
2. **PENDING** - Transaction included in pending block (may be seen in mempool)
3. **ACCEPTED_ON_L2** - Transaction included in L2 block
4. **ACCEPTED_ON_L1** - Transaction finalized on L1 (Ethereum)

**Execution Status**:
- **SUCCEEDED** - Transaction executed successfully
- **REVERTED** - Transaction failed during execution

## Common Use Cases

1. **Transaction Confirmation Waiting**: Wait for specific confirmation levels
2. **User Feedback**: Provide real-time transaction status to users
3. **Automated Workflows**: Trigger actions when transactions are confirmed
4. **Error Handling**: Detect and handle transaction failures immediately
5. **Multi-Step Processes**: Coordinate dependent transactions

## Confirmation Levels

Different applications may require different finality guarantees:

```go
// Wait for L2 acceptance (faster, ~10-30 seconds)
if status.FinalityStatus == "ACCEPTED_ON_L2" {
	// Transaction is in an L2 block
}

// Wait for L1 finality (slower, ~2-4 hours, but more secure)
if status.FinalityStatus == "ACCEPTED_ON_L1" {
	// Transaction is finalized on Ethereum
}
```

## Error Handling

```go
sub, err := wsProvider.SubscribeTransactionStatus(ctx, statusChan, txHash)
if err != nil {
	// Handle subscription errors
	log.Fatal("Failed to subscribe:", err)
}

// Listen for stream errors
go func() {
	err := <-sub.Err()
	if err != nil {
		log.Printf("Stream error: %v", err)
	}
}()

// Handle transaction failures
status := <-statusChan
if status.ExecutionStatus == "REVERTED" {
	log.Printf("Transaction failed: %s", status.RevertReason)
}
```

## Possible Errors

- `ErrTxnHashNotFound` - Transaction hash does not exist
- Connection errors - WebSocket connection issues
- Transaction not found errors

## Related Methods

- [SubscribeEvents](./subscribe-events) - Subscribe to contract events
- [SubscribeNewTransactions](./subscribe-new-transactions) - Subscribe to new transactions
- [SubscribeNewTransactionReceipts](./subscribe-new-transaction-receipts) - Subscribe to transaction receipts
- [GetTransactionStatus](../methods/get-transaction-status) - Query status by hash (non-streaming)
- [TransactionReceipt](../methods/transaction-receipt) - Get transaction receipt

## Specification

Follows the Starknet WebSocket RPC specification for `starknet_subscribeTransactionStatus`.
