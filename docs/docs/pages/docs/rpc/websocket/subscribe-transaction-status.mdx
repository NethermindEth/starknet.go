# SubscribeTransactionStatus

Creates a WebSocket stream which at first fires an event with the current known transaction status, followed by events for every transaction status update. The stream monitors a specific transaction as it progresses through different states until finalization.

import { Callout } from 'vocs/components'

<Callout type="warning">
  **Provider Support**: This WebSocket method may not be supported by all RPC providers. Some providers may have limited support for WebSocket subscriptions. Check your provider's documentation for WebSocket method availability, or consider [running your own Juno node](https://www.youtube.com/watch?v=gvdC2XIOibA) for full WebSocket support.
</Callout>

## Method Signature

```go
func (ws *WsProvider) SubscribeTransactionStatus(
	ctx context.Context,
	newStatus chan<- *NewTxnStatus,
	transactionHash *felt.Felt,
) (*client.ClientSubscription, error)
```

**Source:** [websocket.go:L163-L180](https://github.com/NethermindEth/starknet.go/blob/main/rpc/websocket.go#L163-L180)

## Parameters

- `ctx` (context.Context): The context for controlling the function call
- `newStatus` (chan&lt;- \*NewTxnStatus): The channel to send the new transaction status to
- `transactionHash` (\*felt.Felt): The transaction hash to fetch status updates for

## Returns

- `*client.ClientSubscription`: The client subscription object, used to unsubscribe from the stream and to get errors
- `error`: An error if any occurred

## Type Definitions

### NewTxnStatus

The transaction status notification received from the server.

```go
type NewTxnStatus struct {
	TransactionHash *felt.Felt      `json:"transaction_hash"`
	Status          TxnStatusResult `json:"status"`
}
```

**Source:** [types_transaction_receipt.go:L240-L243](https://github.com/NethermindEth/starknet.go/blob/main/rpc/types_transaction_receipt.go#L240-L243)

### TxnStatusResult

The detailed status information for a transaction.

```go
type TxnStatusResult struct {
	FinalityStatus  TxnStatus          `json:"finality_status"`
	ExecutionStatus TxnExecutionStatus `json:"execution_status,omitempty"`
	// the failure reason, only appears if execution_status is REVERTED
	FailureReason string `json:"failure_reason,omitempty"`
}
```

**Source:** [types_transaction_receipt.go:L232-L237](https://github.com/NethermindEth/starknet.go/blob/main/rpc/types_transaction_receipt.go#L232-L237)

## Usage Example

```go
package main

import (
	"context"
	"fmt"
	"log"
	"os"
	"time"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/joho/godotenv"
)

func main() {
	// Load environment variables
	err := godotenv.Load()
	if err != nil {
		log.Fatal("Error loading .env file")
	}

	wsURL := os.Getenv("STARKNET_WS_URL")
	if wsURL == "" {
		log.Fatal("STARKNET_WS_URL not found in .env file")
	}

	ctx := context.Background()

	// Connect to WebSocket endpoint
	wsProvider, err := rpc.NewWebsocketProvider(ctx, wsURL)
	if err != nil {
		log.Fatal("Failed to connect:", err)
	}
	defer wsProvider.Close()

	// Transaction hash to monitor (replace with actual transaction hash)
	txHash, err := new(felt.Felt).SetString("0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef")
	if err != nil {
		log.Fatal("Invalid transaction hash:", err)
	}

	// Create channel to receive status updates
	statusChan := make(chan *rpc.NewTxnStatus)

	// Subscribe to transaction status updates
	sub, err := wsProvider.SubscribeTransactionStatus(ctx, statusChan, txHash)
	if err != nil {
		log.Fatal("Failed to subscribe:", err)
	}
	defer sub.Unsubscribe()

	fmt.Printf("Successfully subscribed to transaction status\n")
	fmt.Printf("Monitoring transaction: %s\n\n", txHash)

	// Listen for status updates with timeout
	timeout := time.After(60 * time.Second)
	updateCount := 0

	for {
		select {
		case status := <-statusChan:
			updateCount++
			fmt.Printf("Status Update #%d:\n", updateCount)
			fmt.Printf("  Transaction Hash: %s\n", status.TransactionHash)
			fmt.Printf("  Execution Status: %s\n", status.Status.ExecutionStatus)
			fmt.Printf("  Finality Status: %s\n", status.Status.FinalityStatus)

			if status.Status.ExecutionStatus == "REVERTED" {
				fmt.Printf("  Failure Reason: %s\n", status.Status.FailureReason)
			}
			fmt.Println()

			// Check if transaction is finalized
			if status.Status.FinalityStatus == "ACCEPTED_ON_L1" ||
				status.Status.FinalityStatus == "ACCEPTED_ON_L2" {
				fmt.Println("Transaction finalized!")
				if status.Status.ExecutionStatus == "SUCCEEDED" {
					fmt.Println("Transaction executed successfully")
				} else if status.Status.ExecutionStatus == "REVERTED" {
					fmt.Printf("Transaction reverted: %s\n", status.Status.FailureReason)
				}
				fmt.Printf("\nTest completed - received %d status update(s)\n", updateCount)
				return
			}
		case err := <-sub.Err():
			log.Fatal("Subscription error:", err)
		case <-timeout:
			if updateCount > 0 {
				fmt.Printf("Test completed - received %d status update(s)\n", updateCount)
			} else {
				fmt.Println("Timeout - no updates received (transaction hash may not exist)")
			}
			return
		}
	}
}
```

:::note
Create a `.env` file in your project root with `STARKNET_WS_URL` and install the godotenv package to run the code snippet. Replace the placeholder transaction hash with an actual pending or recent transaction hash.
:::

## Error Handling

```go
sub, err := wsProvider.SubscribeTransactionStatus(ctx, statusChan, txHash)
if err != nil {
	log.Printf("Subscription error: %v", err)
	return
}

// Listen for stream errors
go func() {
	err := <-sub.Err()
	if err != nil {
		log.Printf("Stream error: %v", err)
	}
}()

// Handle transaction failures
status := <-statusChan
if status.Status.ExecutionStatus == "REVERTED" {
	log.Printf("Transaction failed: %s", status.Status.FailureReason)
}
```

## Common Use Cases

- Waiting for specific confirmation levels before considering transactions final.
- Providing real-time transaction status updates to users in applications.
- Triggering follow-up actions when transactions are confirmed or finalized.
- Immediately detecting and handling transaction failures with detailed failure reasons.

