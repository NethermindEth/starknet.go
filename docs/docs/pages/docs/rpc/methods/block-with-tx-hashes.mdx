# BlockWithTxHashes

Gets a block with only transaction hashes instead of full transaction details. This method is more efficient than BlockWithTxs when you only need to know which transactions are in a block without their complete data. The response is significantly lighter, making it ideal for monitoring blocks or checking transaction inclusion. 

## Method Signature

```go
func (provider *Provider) BlockWithTxHashes(
    ctx context.Context,
    blockID BlockID,
) (interface{}, error)
```

**Source:** [block.go:L105-L132](https://github.com/NethermindEth/starknet.go/blob/main/rpc/block.go#L105-L132)

## Parameters

- `ctx` (context.Context): Context for request cancellation and timeout
- `blockID` (BlockID): Block identifier (number, hash, or tag like "latest" or "pending")

## Returns

- `interface{}`: The retrieved block (either `*BlockTxHashes` or `*PreConfirmedBlockTxHashes`)
- `error`: Error if the request fails
:::note
The method can return either a confirmed block (`BlockTxHashes`) or a pre-confirmed block (`PreConfirmedBlockTxHashes`) depending on the block status. This can return `ErrBlockNotFound` if the specified block doesn't exist.
:::
## Type Definitions

### BlockID

The `blockID` parameter specifies which block to retrieve. You can identify a block in three ways:

```go
type BlockID struct {
    Number *uint64    `json:"block_number,omitempty"`
    Hash   *felt.Felt `json:"block_hash,omitempty"`
    Tag    BlockTag   `json:"tag,omitempty"`
}
```

**Source:** [types_block.go:L130-L136](https://github.com/NethermindEth/starknet.go/blob/main/rpc/types_block.go#L130-L136)

There are helper functions for creating `BlockID`. So Instead of manually creating the `BlockID` struct, use these convenience functions.

-  By Block Number - Get a specific block by its height

    ```go
    blockID := rpc.WithBlockNumber(123456)
    ```
    Source: [block.go:L59-L64](https://github.com/NethermindEth/starknet.go/blob/main/rpc/block.go#L59-L64)

-  By Block Hash - Get a specific block by its hash

    ```go
    hash, _ := new(felt.Felt).SetString("0x1234...")
    blockID := rpc.WithBlockHash(hash)
    ```
    Source: [block.go:L73-L78](https://github.com/NethermindEth/starknet.go/blob/main/rpc/block.go#L73-L78)

- By Block Tag - Get a dynamic block reference
    ```go
    blockID := rpc.WithBlockTag("latest")      // Latest accepted block
    blockID := rpc.WithBlockTag("pending")     // Block currently being built
    ```
    Source: [block.go:L87-L92](https://github.com/NethermindEth/starknet.go/blob/main/rpc/block.go#L87-L92)
### BlockTxHashes

```go
type BlockTxHashes struct {
    BlockHeader
    Status BlockStatus `json:"status"`
    Transactions []*felt.Felt `json:"transactions"`
}
```

**Source:** [types_block.go:L51-L56](https://github.com/NethermindEth/starknet.go/blob/main/rpc/types_block.go#L51-L56)

## Usage Example

```go
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "log"
    "os"

    "github.com/NethermindEth/starknet.go/rpc"
    "github.com/joho/godotenv"
)

func main() {
    // Load environment variables from .env file
    err := godotenv.Load()
    if err != nil {
        log.Fatal("Error loading .env file")
    }

    // Get RPC URL from environment variable
    rpcURL := os.Getenv("STARKNET_RPC_URL")
    if rpcURL == "" {
        log.Fatal("STARKNET_RPC_URL not found in .env file")
    }

    // Initialize provider
    provider, err := rpc.NewProvider(context.Background(), rpcURL)
    if err != nil {
        log.Fatal(err)
    }

    // Get latest block with transaction hashes
    blockID := rpc.WithBlockTag("latest")
    block, err := provider.BlockWithTxHashes(context.Background(), blockID)
    if err != nil {
        log.Fatal(err)
    }

    // Pretty print the result
    blockJSON, _ := json.MarshalIndent(block, "", "  ")
    fmt.Printf("Block with transaction hashes:\n%s\n", blockJSON)
}
```

:::note
Create a `.env` file in your project root and install the godotenv package to run the code snippet.
:::

## Error Handling

```go
block, err := provider.BlockWithTxHashes(ctx, blockID)
if err != nil {
    switch {
    case errors.Is(err, rpc.ErrBlockNotFound):
        log.Printf("Block not found")
    default:
        log.Printf("Failed to get block: %v", err)
    }
    return
}

fmt.Printf("Successfully retrieved block with transaction hashes\n")
```

## Common Use Cases

- Lightweight Block Monitoring without downloading full transaction data. See [example](/docs/rpc/examples#lightweight-block-monitoring).
- Quickly verifying if a transaction hash is included in a block. See [example](/docs/rpc/examples#transaction-inclusion-check).
- Indexing blocks with minimal data transfer for later detailed queries.
- Analyzing transaction volume and patterns across blocks with minimal overhead.
