# CompiledCasm

Get the CASM (Cairo Assembly) code resulting from compiling a given declared contract class. CASM is the low-level compiled format that is executed on Starknet. Sierra classes are compiled to CASM before execution on the network.

## Method Signature

```go
func (provider *Provider) CompiledCasm(
	ctx context.Context,
	classHash *felt.Felt,
) (*contracts.CasmClass, error)
```

**Source:** [executables.go:L20-L30](https://github.com/NethermindEth/starknet.go/blob/main/rpc/executables.go#L20-L30)

## Parameters

- `ctx` (context.Context): Context for request cancellation and timeouts
- `classHash` (*felt.Felt): The hash of the declared class

## Returns

- `*contracts.CasmClass`: The compiled CASM class containing bytecode, entry points, prime, compiler version, and hints
- `error`: Error if any occurred (`ErrClassHashNotFound`, `ErrCompilationError`)

## Type Definitions

### CasmClass

The struct that represents the compiled Cairo contract class (CASM_COMPILED_CONTRACT_CLASS).

```go
type CasmClass struct {
	EntryPointsByType CasmEntryPointsByType `json:"entry_points_by_type"`
	ByteCode          []*felt.Felt          `json:"bytecode"`
	Prime             NumAsHex              `json:"prime"`
	CompilerVersion   string                `json:"compiler_version"`
	Hints             []Hints               `json:"hints"`
	// a list of sizes of segments in the bytecode, each segment is hashed
	// individually when computing the bytecode hash
	BytecodeSegmentLengths *NestedUints `json:"bytecode_segment_lengths,omitempty"`
}
```

**Source:** [types_casm_class.go:L11-L22](https://github.com/NethermindEth/starknet.go/blob/main/contracts/types_casm_class.go#L11-L22)

### CasmEntryPointsByType

```go
type CasmEntryPointsByType struct {
	Constructor []CasmEntryPoint `json:"CONSTRUCTOR"`
	External    []CasmEntryPoint `json:"EXTERNAL"`
	L1Handler   []CasmEntryPoint `json:"L1_HANDLER"`
}
```

**Source:** [types_casm_class.go:L62-L66](https://github.com/NethermindEth/starknet.go/blob/main/contracts/types_casm_class.go#L62-L66)

### CasmEntryPoint

```go
type CasmEntryPoint struct {
	Selector *felt.Felt `json:"selector"`
	Offset   uint       `json:"offset"`
	Builtins []string   `json:"builtins"`
}
```

**Source:** [types_casm_class.go:L68-L72](https://github.com/NethermindEth/starknet.go/blob/main/contracts/types_casm_class.go#L68-L72)

## Usage Example

```go
package main

import (
	"context"
	"fmt"
	"log"
	"os"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/joho/godotenv"
)

func main() {
	// Load environment variables from .env file
	err := godotenv.Load()
	if err != nil {
		log.Fatal("Error loading .env file")
	}

	// Get RPC URL from environment variable
	rpcURL := os.Getenv("STARKNET_RPC_URL")
	if rpcURL == "" {
		log.Fatal("STARKNET_RPC_URL not found in .env file")
	}

	// Initialize provider
	ctx := context.Background()
	client, err := rpc.NewProvider(ctx, rpcURL)
	if err != nil {
		log.Fatal(err)
	}

	// Class hash of a declared contract
	classHash, _ := new(felt.Felt).SetString("0x05400e90f7e0ae78bd02c77cd75527280470e2fe19c54970dd79dc37a9d3645c")

	// Get compiled CASM
	casmClass, err := client.CompiledCasm(ctx, classHash)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Printf("Prime: %s\n", casmClass.Prime)
	fmt.Printf("Compiler Version: %s\n", casmClass.CompilerVersion)
	fmt.Printf("Bytecode Length: %d\n", len(casmClass.ByteCode))
	fmt.Printf("External Entry Points: %d\n", len(casmClass.EntryPointsByType.External))
}
```

:::note
Create a `.env` file in your project root and install the godotenv package to run the code snippet.
:::

## Error Handling

```go
casmClass, err := client.CompiledCasm(ctx, classHash)
if err != nil {
	switch {
	case errors.Is(err, rpc.ErrClassHashNotFound):
		log.Println("Class not declared")
		return
	case errors.Is(err, rpc.ErrCompilationError):
		log.Println("Sierra compilation failed")
		return
	default:
		log.Printf("RPC error: %v", err)
		return
	}
}

fmt.Printf("Successfully retrieved CASM for class %s\n", classHash.String())
```

## Common Use Cases

- Examining the compiled bytecode of a contract to understand its low-level implementation.
- Understanding the low-level execution flow of contract functions for debugging purposes.
- Verifying that Sierra code compiles to the expected CASM bytecode.
- Analyzing bytecode for optimization opportunities and gas efficiency improvements.

