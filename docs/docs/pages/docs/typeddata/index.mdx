# TypedData Package

The TypedData package provides functionality for working with typed structured data on Starknet, implementing the SNIP-12 standard for off-chain message signing with type safety and domain separation.

## Overview

TypedData implements Starknet's equivalent of Ethereum's EIP-712, enabling applications to create structured, human-readable messages for signing. This is essential for authentication, permits, meta-transactions, and other signature-based operations that require users to understand what they're signing.

The package provides:

- **Type-Safe Messages**: Define structured message formats with strict type definitions
- **Domain Separation**: Prevent signature replay across different applications and chains
- **Multiple Revisions**: Support for Revision 0 (Pedersen) and Revision 1 (Poseidon hashing)
- **Complex Types**: Handle nested structs, arrays, enums, and preset types
- **SNIP-12 Compliance**: Fully compatible with the Starknet typed data standard

## Key Components

- [NewTypedData](/docs/typeddata/functions/new-typed-data) - Create a new TypedData instance from types, domain, and message
- [GetMessageHash](/docs/typeddata/methods/get-message-hash) - Generate the hash of a message for a specific account
- [GetStructHash](/docs/typeddata/methods/get-struct-hash) - Calculate the hash of a struct type
- [GetTypeHash](/docs/typeddata/methods/get-type-hash) - Get the hash of a type definition
- [EncodeData](/docs/typeddata/functions/encode-data) - Encode typed data into felt array
- [GetRevision](/docs/typeddata/functions/get-revision) - Get the revision object for a version number

## Getting Started

To use the TypedData package, import it in your Go code:

```go
import "github.com/NethermindEth/starknet.go/typeddata"
```

## Quick Example

```go
package main

import (
	"encoding/json"
	"fmt"
	"log"

	"github.com/NethermindEth/starknet.go/typeddata"
)

func main() {
	// Define typed data JSON (SNIP-12 format)
	typedDataJSON := []byte(`{
		"types": {
			"StarkNetDomain": [
				{ "name": "name", "type": "felt" },
				{ "name": "version", "type": "felt" },
				{ "name": "chainId", "type": "felt" }
			],
			"Mail": [
				{ "name": "from", "type": "felt" },
				{ "name": "to", "type": "felt" },
				{ "name": "contents", "type": "felt" }
			]
		},
		"primaryType": "Mail",
		"domain": {
			"name": "StarkNet Mail",
			"version": "1",
			"chainId": "SN_SEPOLIA"
		},
		"message": {
			"from": "0x1234",
			"to": "0x5678",
			"contents": "Hello!"
		}
	}`)

	// Unmarshal typed data
	var td typeddata.TypedData
	err := json.Unmarshal(typedDataJSON, &td)
	if err != nil {
		log.Fatalf("Failed to unmarshal: %v", err)
	}

	// Get message hash for signing
	accountAddress := "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826"
	messageHash, err := td.GetMessageHash(accountAddress)
	if err != nil {
		log.Fatalf("Failed to get hash: %v", err)
	}

	fmt.Printf("Message Hash: %s\n", messageHash.String())
}
```

For more examples, see the [Examples page](/docs/typeddata/examples).

## How TypedData Works in Starknet

### SNIP-12 Standard

SNIP-12 (Starknet Improvement Proposal 12) defines how structured data should be hashed and signed on Starknet. It ensures that:

1. **Messages are structured** - Data follows predefined type schemas
2. **Hashes are deterministic** - Same data always produces the same hash
3. **Domains are separated** - Signatures can't be replayed across different apps
4. **Types are validated** - The signer knows exactly what they're signing

### Type System

The TypedData type system supports:

- **Basic types**: felt, bool, string, selector
- **Numeric types** (Rev 1): u128, i128, timestamp
- **Address types** (Rev 1): ContractAddress, ClassHash
- **Complex types**: Structs, arrays, enums (Rev 1)
- **Preset types** (Rev 1): u256, TokenAmount, NftId

### Domain Separation

Each TypedData includes a domain object specifying:

- **name**: Application name (e.g., "MyDapp")
- **version**: Application version (e.g., "1")
- **chainId**: Network identifier (e.g., "SN_MAIN", "SN_SEPOLIA")
- **revision**: Hash algorithm version (0 = Pedersen, 1 = Poseidon)

This prevents signatures from one application or network being used in another.

### Hash Computation

The message hash is computed as:

```
messageHash = hash(
    structHash(domain),
    accountAddress,
    structHash(message)
)
```

Where `structHash` recursively hashes all fields according to their types.

## Choosing the Right Approach

### Revision 0 vs Revision 1

- **Use Revision 1** when:
  - Building new applications (recommended)
  - Need Poseidon hashing (more efficient)
  - Want enum support
  - Working with u256, TokenAmount, NftId preset types
  - Need ContractAddress, ClassHash types

- **Use Revision 0** when:
  - Maintaining compatibility with older applications
  - Working with systems that only support Pedersen hashing
  - Using basic felt/bool/string types only

### JSON vs Programmatic Creation

- **Use JSON unmarshaling** when:
  - Receiving typed data from frontend/API
  - Working with standardized message formats
  - Need easy integration with web wallets

- **Use NewTypedData** when:
  - Building typed data programmatically in Go
  - Need fine-grained control over type definitions
  - Generating messages dynamically

## Use Cases

- **Authentication**: Sign login messages to prove account ownership without gas costs
- **Permits**: Off-chain token approvals (EIP-2612 style) for gasless transactions
- **Meta-Transactions**: Sign transaction parameters for relayer submission
- **Voting**: Off-chain governance voting with cryptographic proof
- **Session Keys**: Authorize temporary keys with specific permissions
- **Gasless Onboarding**: Let users interact before funding their accounts

## Revisions

### Revision 0
- Hash algorithm: Pedersen
- Basic types: felt, bool, string, selector, merkletree
- Used by: Early Starknet applications

### Revision 1
- Hash algorithm: Poseidon (more efficient)
- All Revision 0 types plus:
  - Numeric: u128, i128, timestamp
  - Addresses: ContractAddress, ClassHash
  - String: shortstring
  - Complex: enums
  - Presets: u256, TokenAmount, NftId
- Recommended for: New applications

## SNIP-12 Resources

- [SNIP-12 Specification](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-12.md)
- [Starknet Signing Standards](https://community.starknet.io/t/signing-transactions-and-off-chain-messages/66)

:::tip
Best Practices
- Always use Revision 1 for new applications to benefit from Poseidon hashing efficiency
- Include all relevant domain fields (name, version, chainId) for proper separation
- Validate typed data structure before asking users to sign
- Display human-readable message content to users before signing
- Store domain and types definitions for signature verification later
:::

:::note
See the [Examples page](/docs/typeddata/examples) for comprehensive examples covering:
- Basic message signing workflow
- Working with different revisions
- Complex nested types and structs
- Preset types (u256, TokenAmount, NftId)
- Domain separation patterns
- Integration with account signing
:::
