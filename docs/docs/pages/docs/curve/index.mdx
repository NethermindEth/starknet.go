# Curve Package

The Curve package provides cryptographic primitives for Starknet applications, including hash functions, digital signatures, and elliptic curve operations. This package is fundamental for transaction signing, key management, and cryptographic hashing throughout the Starknet ecosystem.

## Overview

Starknet uses specialized cryptographic functions optimized for zero-knowledge proof systems. The curve package implements these primitives on the Stark curve (a variant of the NIST P-256 curve) and provides:

- **Hash Functions**: Pedersen, Poseidon, and Keccak variants for different use cases
- **Digital Signatures**: ECDSA signing and verification for transaction authorization
- **Key Management**: Key pair generation and elliptic curve point operations
- **Type Flexibility**: Functions available in both `*big.Int` and `*felt.Felt` variants

## Key Components

### Hash Functions
- [Pedersen](/docs/curve/functions/pedersen) - Hash two field elements (legacy, widely used)
- [PedersenArray](/docs/curve/functions/pedersen-array) - Hash multiple field elements
- [Poseidon](/docs/curve/functions/poseidon) - SNARK-friendly hash of two elements
- [PoseidonArray](/docs/curve/functions/poseidon-array) - SNARK-friendly hash of arrays
- [StarknetKeccak](/docs/curve/functions/starknet-keccak) - Compute function selectors
- [ComputeHashOnElements](/docs/curve/functions/compute-hash-on-elements) - Hash with length prefix
- [HashPedersenElements](/docs/curve/functions/hash-pedersen-elements) - Sequential Pedersen hashing

### Signature Functions
- [Sign](/docs/curve/functions/sign) - Sign message hashes with private keys
- [SignFelts](/docs/curve/functions/sign-felts) - Sign using felt types
- [Verify](/docs/curve/functions/verify) - Verify ECDSA signatures
- [VerifyFelts](/docs/curve/functions/verify-felts) - Verify signatures using felt types

### Key Operations
- [GetRandomKeys](/docs/curve/functions/get-random-keys) - Generate secure random key pairs
- [PrivateKeyToPoint](/docs/curve/functions/private-key-to-point) - Derive public key from private key
- [GetYCoordinate](/docs/curve/functions/get-y-coordinate) - Calculate Y coordinate from X

## Getting Started

To use the curve package, import it in your Go code:

```go
import "github.com/NethermindEth/starknet.go/curve"
```

## Quick Example

```go
package main

import (
	"fmt"
	"log"
	"math/big"

	"github.com/NethermindEth/starknet.go/curve"
)

func main() {
	// Generate a random key pair
	privKey, pubKeyX, _, err := curve.GetRandomKeys()
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("Public key: %x\n", pubKeyX)

	// Sign a message hash
	msgHash := big.NewInt(12345)
	r, s, err := curve.Sign(msgHash, privKey)
	if err != nil {
		log.Fatal(err)
	}

	// Verify the signature
	valid, err := curve.Verify(msgHash, r, s, pubKeyX)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("Signature valid: %v\n", valid)
}
```

For more examples, see the [Examples page](/docs/curve/examples).

## How Cryptographic Operations Work in Starknet

### Hash Functions

Starknet uses two primary hash functions, each optimized for different purposes:

**Pedersen Hash**: The legacy hash function used throughout Starknet's history. It's widely supported in existing contracts and infrastructure. Pedersen hashing is collision-resistant and suitable for Merkle trees, state commitments, and contract address calculations.

**Poseidon Hash**: A modern hash function designed specifically for zero-knowledge proof systems. Poseidon is significantly more efficient than Pedersen when used inside STARK proofs, making it ideal for new implementations where proof generation cost matters.

**Keccak**: Used primarily for computing function selectors from function names. The `StarknetKeccak` variant ensures compatibility with Starknet's selector computation standard.

### Digital Signatures

Starknet uses ECDSA (Elliptic Curve Digital Signature Algorithm) on the Stark curve for all signatures. Every transaction must be signed with the account's private key, producing two values (r, s) that form the signature. The signature proves that the transaction was authorized by the account owner without revealing the private key.

The verification process uses the public key (specifically the x-coordinate, which serves as the Starknet account identifier) to confirm the signature's authenticity.

### Key Management

Starknet accounts are controlled by elliptic curve key pairs. The private key is a secret number that must be kept secure, while the public key's x-coordinate serves as the account's public identifier and is used for signature verification.

Key generation uses cryptographically secure random number generation to ensure unpredictability. The public key is derived from the private key through elliptic curve scalar multiplication, a one-way operation that makes it computationally infeasible to recover the private key from the public key.

## Choosing the Right Function

### Hash Function Selection

- **Use Pedersen** when:
  - Working with existing contracts that expect Pedersen hashes
  - Building Merkle trees for state commitments
  - Calculating contract addresses (follows legacy standard)
  - Interacting with older Starknet infrastructure

- **Use Poseidon** when:
  - Building new contracts where proof efficiency matters
  - Implementing ZK-friendly protocols
  - Optimizing for proof generation costs
  - Working with Cairo 1.0+ contracts

- **Use StarknetKeccak** when:
  - Computing function selectors from function names
  - Hashing arbitrary byte strings to field elements

### Signature Function Selection

- **Use Sign/Verify** when:
  - Working with `*big.Int` types throughout your application
  - Integrating with systems that use big integers
  - Maximum compatibility with Go's standard library

- **Use SignFelts/VerifyFelts** when:
  - Working with Starknet's `felt.Felt` types
  - Building applications that primarily use Juno's felt library
  - Avoiding type conversions between big.Int and felt

## Use Cases

- **Transaction Signing**: Sign transaction hashes before submitting to Starknet
- **Account Creation**: Generate secure key pairs for new Starknet accounts
- **Function Selectors**: Compute selectors for contract function calls
- **State Commitments**: Create Merkle trees and hash state data
- **Signature Verification**: Validate that transactions were signed by expected accounts
- **Key Derivation**: Derive public keys from private keys for address calculation

:::note
See the [Examples page](/docs/curve/examples) for comprehensive examples covering:
- Pedersen and PedersenArray hashing
- StarknetKeccak selector computation
- Key pair generation and management
- Complete sign and verify workflows

:::tip 
Security Best Practices
- Never log or store private keys unencrypted.
- Use `GetRandomKeys()` for secure key generation.
- Always verify signatures before trusting signed data.
- Use Poseidon for new implementations (unless Pedersen compatibility required).
:::

