# PoseidonArray

Computes the Poseidon hash of multiple field elements. This function extends the two-input Poseidon hash to handle arrays of any length, providing efficient hashing for variable-length data in SNARK-friendly applications.

## Function Signature

```go
func PoseidonArray(felts ...*felt.Felt) *felt.Felt
```

**Source:** [curve.go:L274-L286](https://github.com/NethermindEth/starknet.go/blob/main/curve/curve.go#L274-L286)

## Parameters

- `felts` (...*felt.Felt): Variadic number of field elements to hash

## Returns

- `*felt.Felt`: The Poseidon hash of all inputs

## Usage Example

```go
package main

import (
	"fmt"
	"log"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/curve"
)

func main() {
	// Create array of felt values
	felt1 := new(felt.Felt).SetUint64(1)
	felt2 := new(felt.Felt).SetUint64(2)
	felt3 := new(felt.Felt).SetUint64(3)
	felt4 := new(felt.Felt).SetUint64(4)

	// Compute Poseidon hash of array
	hash := curve.PoseidonArray(felt1, felt2, felt3, felt4)
	if hash == nil {
		log.Fatal("Failed to compute PoseidonArray hash")
	}

	fmt.Println("PoseidonArray Hash:")
	fmt.Printf("  Input: [%s, %s, %s, %s]\n", felt1.String(), felt2.String(), felt3.String(), felt4.String())
	fmt.Printf("  Hash: %s\n", hash.String())
}
```

## Common Use Cases

- Hash multiple transaction fields together when building ZK-STARK applications that require efficient multi-element hashing.
- Compute commitments to arrays of data where SNARK-friendly operations provide performance benefits.
- Use when working with Starknet protocols that require Poseidon hashing for arrays with variable number of elements.
- Process calldata arrays efficiently when building smart contract interactions that leverage ZK-STARK properties.

