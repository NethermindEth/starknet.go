# Pedersen

Computes the Pedersen hash of two field elements. This cryptographic hash function is used extensively throughout Starknet for Merkle trees, state commitments, and contract address calculations. The Pedersen hash is deterministic (same inputs always produce the same output), collision-resistant, and the output is always a valid field element in the Starknet field.

## Function Signature

```go
func Pedersen(a, b *felt.Felt) *felt.Felt
```

**Source:** [curve.go:L245-L247](https://github.com/NethermindEth/starknet.go/blob/main/curve/curve.go#L245-L247)

## Parameters

- `a` (*felt.Felt): First field element to hash
- `b` (*felt.Felt): Second field element to hash

## Returns

- `*felt.Felt`: The Pedersen hash of the two inputs

## Usage Example

```go
package main

import (
	"fmt"
	"log"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/curve"
)

func main() {
	// Create two felt values to hash
	a := new(felt.Felt).SetUint64(123)
	b := new(felt.Felt).SetUint64(456)

	// Compute Pedersen hash
	hash := curve.Pedersen(a, b)
	if hash == nil {
		log.Fatal("Failed to compute Pedersen hash")
	}

	fmt.Println("Pedersen Hash:")
	fmt.Printf("  Input a: %s\n", a.String())
	fmt.Printf("  Input b: %s\n", b.String())
	fmt.Printf("  Hash: %s\n", hash.String())
}
```

## Common Use Cases

- Build Merkle trees by hashing pairs of sibling nodes together to create parent nodes.
- Create state commitments by hashing key-value pairs for contract storage.
- Calculate contract addresses as part of the address derivation process that combines salts and class hashes.
- Hash two field elements together when you need collision-resistant cryptographic hashing in Starknet applications.
- For hashing more than two elements, use [PedersenArray](/docs/curve/functions/pedersen-array) instead.

