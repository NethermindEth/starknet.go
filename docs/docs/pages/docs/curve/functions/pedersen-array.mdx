# PedersenArray

Computes the Pedersen hash of multiple field elements. This function extends the two-input Pedersen hash to handle arrays of any length, making it ideal for hashing transaction data, calldata arrays, and other multi-element structures in Starknet applications.

## Function Signature

```go
func PedersenArray(felts ...*felt.Felt) *felt.Felt
```

**Source:** [curve.go:L270-L272](https://github.com/NethermindEth/starknet.go/blob/main/curve/curve.go#L270-L272)

## Parameters

- `felts` (...*felt.Felt): Variadic number of field elements to hash

## Returns

- `*felt.Felt`: The Pedersen hash of all inputs

## Usage Example

```go
package main

import (
	"fmt"
	"log"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/curve"
)

func main() {
	// Create array of felt values
	felt1 := new(felt.Felt).SetUint64(1)
	felt2 := new(felt.Felt).SetUint64(2)
	felt3 := new(felt.Felt).SetUint64(3)
	felt4 := new(felt.Felt).SetUint64(4)

	// Compute Pedersen hash of array
	hash := curve.PedersenArray(felt1, felt2, felt3, felt4)
	if hash == nil {
		log.Fatal("Failed to compute PedersenArray hash")
	}

	fmt.Println("PedersenArray Hash:")
	fmt.Printf("  Input: [%s, %s, %s, %s]\n", felt1.String(), felt2.String(), felt3.String(), felt4.String())
	fmt.Printf("  Hash: %s\n", hash.String())
}
```

## Common Use Cases

- Hash multiple transaction fields together (nonce, amount, recipient, etc.) to create transaction commitments.
- Compute hashes of calldata arrays when invoking contract functions with multiple parameters.
- Create commitments to arrays of data where you need to hash more than two field elements at once.
- Use when you have a variable number of elements to hash and want a single deterministic hash output.

