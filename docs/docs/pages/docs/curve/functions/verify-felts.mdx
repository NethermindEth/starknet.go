# VerifyFelts

Verifies a signature using felt.Felt parameters. This is the felt.Felt variant of [Verify](/docs/curve/functions/verify) that provides more ergonomic handling when working with Starknet native types.

## Function Signature

```go
func VerifyFelts(msgHash, r, s, pubX *felt.Felt) (bool, error)
```

**Source:** [curve.go:L39-L57](https://github.com/NethermindEth/starknet.go/blob/main/curve/curve.go#L39-L57)

## Parameters

- `msgHash` (*felt.Felt): Message hash that was signed
- `r`, `s` (*felt.Felt): Signature components
- `pubX` (*felt.Felt): Public key X coordinate

## Returns

- `bool`: true if signature is valid, false otherwise
- `error`: Error if verification fails

## Usage Example

```go
package main

import (
	"fmt"
	"log"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/curve"
)

func main() {
	// Message hash
	msgHash, _ := new(felt.Felt).SetString("0x1234567890abcdef")

	// Signature components (from SignFelts)
	r, _ := new(felt.Felt).SetString("0x4d2b6e6e88e01af828b0f68237ffde7e6742ae86169a89c32185141ad1c6e7e")
	s, _ := new(felt.Felt).SetString("0x4d6f5fe7927e73ffddd5bca9ea3be17e0ae62d12e34c772691fc7b829904f92")

	// Public key X coordinate
	pubX, _ := new(felt.Felt).SetString("0x1ef15c18599971b7beced415a40f0c7deacfd9b0d1819e03d723d8bc943cfca")

	// Verify signature
	valid, err := curve.VerifyFelts(msgHash, r, s, pubX)
	if err != nil {
		log.Fatal("Verification failed:", err)
	}

	fmt.Println("VerifyFelts:")
	fmt.Printf("  Message Hash: %s\n", msgHash.String())
	fmt.Printf("  Signature R: %s\n", r.String())
	fmt.Printf("  Signature S: %s\n", s.String())
	fmt.Printf("  Public Key X: %s\n", pubX.String())
	fmt.Printf("  Valid: %v\n", valid)
}
```

## Common Use Cases

- Verify transaction signatures in Starknet applications using native felt.Felt types.
- Validate signatures for smart contract interactions that require felt.Felt compatibility.
- Check message signatures in authentication workflows for Starknet accounts.
- Use when working with Starknet types rather than big.Int for better ergonomics and type safety.

