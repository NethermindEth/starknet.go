# Sign

Signs a message hash using the Stark curve ECDSA algorithm. This function produces a deterministic signature with R and S components that can be verified using the corresponding public key.

## Function Signature

```go
func Sign(msgHash, privKey *big.Int) (r, s *big.Int, err error)
```

**Source:** [curve.go:L59-L98](https://github.com/NethermindEth/starknet.go/blob/main/curve/curve.go#L59-L98)

## Parameters

- `msgHash` (*big.Int): The message hash to sign
- `privKey` (*big.Int): The private key for signing

## Returns

- `r` (*big.Int): The R component of the signature
- `s` (*big.Int): The S component of the signature
- `err` (error): Error if signing fails

## Usage Example

```go
package main

import (
	"fmt"
	"log"
	"math/big"

	"github.com/NethermindEth/starknet.go/curve"
)

func main() {
	// Generate a key pair
	privKey, pubX, _, err := curve.GetRandomKeys()
	if err != nil {
		log.Fatal("Failed to generate keys:", err)
	}

	// Message hash to sign
	msgHash := new(big.Int)
	msgHash.SetString("1234567890abcdef", 16)

	// Sign the message
	r, s, err := curve.Sign(msgHash, privKey)
	if err != nil {
		log.Fatal("Failed to sign message:", err)
	}

	fmt.Println("Sign:")
	fmt.Printf("  Message Hash: 0x%x\n", msgHash)
	fmt.Printf("  Private Key: 0x%x\n", privKey)
	fmt.Printf("  Public Key X: 0x%x\n", pubX)
	fmt.Printf("  Signature R: 0x%x\n", r)
	fmt.Printf("  Signature S: 0x%x\n", s)
}
```

## Common Use Cases

- Sign transaction hashes to authorize operations on Starknet accounts.
- Create message signatures for authentication and verification workflows.
- Generate signatures for multi-signature setups where multiple parties sign the same message.
- Use when working with big.Int types for interoperability with other Go libraries, otherwise prefer [SignFelts](/docs/curve/functions/sign-felts).

