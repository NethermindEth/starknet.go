# Sign

Signs a message hash using a stored private key. This method retrieves the private key for the given identifier and uses it to sign the message hash using ECDSA on the Starknet curve. The method is thread-safe and respects context cancellation.

## Method Signature

```go
func (ks *MemKeystore) Sign(
	ctx context.Context,
	id string,
	msgHash *big.Int,
) (r, s *big.Int, err error)
```

**Source:** [keystore.go:L104](https://github.com/NethermindEth/starknet.go/blob/main/account/keystore.go#L104)

## Parameters

- `ctx` - Context for cancellation and timeout
- `id` - Identifier for the key (typically public key)
- `msgHash` - Message hash to sign

## Returns

- `r` - R component of the signature
- `s` - S component of the signature
- `err` - Error if signing fails

## Usage Example

```go
package main

import (
	"context"
	"fmt"
	"log"
	"math/big"

	"github.com/NethermindEth/starknet.go/account"
)

func main() {
	ctx := context.Background()

	pubKey := "0x3b8abf14ab2632589812dd0ca906cc314afe293e8d69a5852af0178859ab053"
	privKey, _ := new(big.Int).SetString("0x1e7fcb94882a17e2313ddb9d5f037c33cc17601703f7e41c47bbbcc426d0b10", 0)

	ks := account.NewMemKeystore()
	ks.Put(pubKey, privKey)
	fmt.Printf("Put: Added key to keystore\n")
	fmt.Printf("  Public Key:  %s\n\n", pubKey)

	retrievedKey, err := ks.Get(pubKey)
	if err != nil {
		log.Fatal("Get failed:", err)
	}
	fmt.Printf("Get: Retrieved private key\n")
	fmt.Printf("  Match: %v\n\n", retrievedKey.Cmp(privKey) == 0)

	msgHash := new(big.Int).SetUint64(12345)
	r, s, err := ks.Sign(ctx, pubKey, msgHash)
	if err != nil {
		log.Fatal("Sign failed:", err)
	}

	fmt.Printf("Sign: Signed message hash\n")
	fmt.Printf("  Message: %s\n", msgHash.String())
	fmt.Printf("  Signature r: %s\n", r.String())
	fmt.Printf("  Signature s: %s\n", s.String())
}
```

## Error Handling

```go
r, s, err := ks.Sign(ctx, id, msgHash)
if err != nil {
	// Handle errors (key not found, context cancelled, signing failure)
	return err
}
```

## Common Use Cases

- Signing transaction hashes for blockchain submission
- Creating ECDSA signatures for message authentication
- Implementing custom signing workflows with keystore
- Low-level signature generation for off-chain verification
- Multi-key signing operations from a single keystore
