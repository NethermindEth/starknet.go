# Put

Stores a private key in the MemKeystore indexed by a string identifier (typically the public key). The method is thread-safe and can be called multiple times to update or add keys.

## Method Signature

```go
func (ks *MemKeystore) Put(senderAddress string, k *big.Int)
```

**Source:** [keystore.go](https://github.com/NethermindEth/starknet.go/blob/main/account/keystore.go)

## Parameters

- `senderAddress` - Identifier for the key (typically public key)
- `k` - Private key to store

## Returns

None

## Usage Example

```go
package main

import (
	"context"
	"fmt"
	"log"
	"math/big"

	"github.com/NethermindEth/starknet.go/account"
)

func main() {
	ctx := context.Background()

	pubKey := "0x3b8abf14ab2632589812dd0ca906cc314afe293e8d69a5852af0178859ab053"
	privKey, _ := new(big.Int).SetString("0x1e7fcb94882a17e2313ddb9d5f037c33cc17601703f7e41c47bbbcc426d0b10", 0)

	ks := account.NewMemKeystore()
	ks.Put(pubKey, privKey)
	fmt.Printf("Put: Added key to keystore\n")
	fmt.Printf("  Public Key:  %s\n\n", pubKey)

	retrievedKey, err := ks.Get(pubKey)
	if err != nil {
		log.Fatal("Get failed:", err)
	}
	fmt.Printf("Get: Retrieved private key\n")
	fmt.Printf("  Match: %v\n\n", retrievedKey.Cmp(privKey) == 0)

	msgHash := new(big.Int).SetUint64(12345)
	r, s, err := ks.Sign(ctx, pubKey, msgHash)
	if err != nil {
		log.Fatal("Sign failed:", err)
	}

	fmt.Printf("Sign: Signed message hash\n")
	fmt.Printf("  Message: %s\n", msgHash.String())
	fmt.Printf("  Signature r: %s\n", r.String())
	fmt.Printf("  Signature s: %s\n", s.String())
}
```

## Error Handling

Put does not return errors. It silently adds or overwrites keys in the keystore.

## Common Use Cases

- Adding private keys to keystore after loading from secure storage
- Storing generated key pairs for account management
- Updating keys when rotating credentials
- Managing multiple account keys in a single keystore
