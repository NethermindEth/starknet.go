# TransactionHashInvoke

Calculates the transaction hash for an invoke transaction. This method computes the hash based on the invoke transaction version (V0, V1, or V3) using the appropriate hashing algorithm for each version. The computed hash is used for signing the transaction.

## Method Signature

```go
func (account *Account) TransactionHashInvoke(tx rpc.InvokeTxnType) (*felt.Felt, error)
```

**Source:** [txn_hash.go:L60-L83](https://github.com/NethermindEth/starknet.go/blob/main/account/txn_hash.go#L60-L83)

## Parameters

- `tx` - Invoke transaction (V0, V1, or V3)

## Returns

- `*felt.Felt` - Transaction hash
- `error` - Error if hash calculation fails

## Usage Example

```go
package main

import (
	"context"
	"fmt"
	"log"
	"math/big"
	"os"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/account"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/NethermindEth/starknet.go/utils"
	"github.com/joho/godotenv"
)

func main() {
	ctx := context.Background()

	if err := godotenv.Load(); err != nil {
		log.Fatal("Failed to load .env file:", err)
	}

	rpcURL := os.Getenv("STARKNET_RPC_URL")
	if rpcURL == "" {
		log.Fatal("STARKNET_RPC_URL not set")
	}

	provider, err := rpc.NewProvider(ctx, rpcURL)
	if err != nil {
		log.Fatal("Failed to create provider:", err)
	}

	accountAddress := os.Getenv("ACCOUNT_ADDRESS")
	publicKey := os.Getenv("ACCOUNT_PUBLIC_KEY")
	privateKey := os.Getenv("ACCOUNT_PRIVATE_KEY")

	if accountAddress == "" || publicKey == "" || privateKey == "" {
		log.Fatal("Account credentials not set in .env")
	}

	ks := account.NewMemKeystore()
	privKeyBI, ok := new(big.Int).SetString(privateKey, 0)
	if !ok {
		log.Fatal("Failed to parse private key")
	}
	ks.Put(publicKey, privKeyBI)

	accountAddressFelt, err := utils.HexToFelt(accountAddress)
	if err != nil {
		log.Fatal("Failed to parse account address:", err)
	}

	accnt, err := account.NewAccount(provider, accountAddressFelt, publicKey, ks, account.CairoV2)
	if err != nil {
		log.Fatal("Failed to create account:", err)
	}

	nonce, _ := accnt.Nonce(ctx)

	strkContract, _ := utils.HexToFelt("0x04718f5a0fc34cc1af16a1cdee98ffb20c31f5cd61d6ab07201858f4287c938d")
	recipient := accountAddressFelt
	amount := new(felt.Felt).SetUint64(1000000000000000)
	u256Amount, _ := utils.HexToU256Felt(amount.String())

	fnCall := rpc.FunctionCall{
		ContractAddress:    strkContract,
		EntryPointSelector: utils.GetSelectorFromNameFelt("transfer"),
		Calldata:           append([]*felt.Felt{recipient}, u256Amount...),
	}

	calldata, _ := accnt.FmtCalldata([]rpc.FunctionCall{fnCall})

	invokeTxnV3 := utils.BuildInvokeTxn(
		accnt.Address,
		nonce,
		calldata,
		&rpc.ResourceBoundsMapping{
			L1Gas:     rpc.ResourceBounds{MaxAmount: "0x186a0", MaxPricePerUnit: "0x5f5e100"},
			L2Gas:     rpc.ResourceBounds{MaxAmount: "0x186a0", MaxPricePerUnit: "0x5f5e100"},
			L1DataGas: rpc.ResourceBounds{MaxAmount: "0x186a0", MaxPricePerUnit: "0x5f5e100"},
		},
		nil,
	)

	txHashV3, err := accnt.TransactionHashInvoke(invokeTxnV3)
	if err != nil {
		log.Fatal("Failed to compute V3 hash:", err)
	}

	fmt.Printf("V3 Transaction:\n")
	fmt.Printf("  Sender:   %s\n", invokeTxnV3.SenderAddress.String())
	fmt.Printf("  Nonce:    %d\n", invokeTxnV3.Nonce.Uint64())
	fmt.Printf("  Calldata: %d elements\n", len(invokeTxnV3.Calldata))
	fmt.Printf("  Hash:     %s\n\n", txHashV3.String())

	invokeTxnV1 := &rpc.InvokeTxnV1{
		Type:          rpc.TransactionTypeInvoke,
		Version:       rpc.TransactionV1,
		SenderAddress: accnt.Address,
		Nonce:         nonce,
		Calldata:      calldata,
		MaxFee:        new(felt.Felt).SetUint64(1000000000000000),
		Signature:     []*felt.Felt{},
	}

	txHashV1, err := accnt.TransactionHashInvoke(invokeTxnV1)
	if err != nil {
		log.Fatal("Failed to compute V1 hash:", err)
	}

	fmt.Printf("V1 Transaction:\n")
	fmt.Printf("  Sender: %s\n", invokeTxnV1.SenderAddress.String())
	fmt.Printf("  Nonce:  %d\n", invokeTxnV1.Nonce.Uint64())
	fmt.Printf("  MaxFee: %s\n", invokeTxnV1.MaxFee.String())
	fmt.Printf("  Hash:   %s\n\n", txHashV1.String())

	invokeTxnV0 := &rpc.InvokeTxnV0{
		Type:    rpc.TransactionTypeInvoke,
		Version: rpc.TransactionV0,
		FunctionCall: rpc.FunctionCall{
			ContractAddress:    strkContract,
			EntryPointSelector: utils.GetSelectorFromNameFelt("transfer"),
			Calldata:           fnCall.Calldata,
		},
		MaxFee:    new(felt.Felt).SetUint64(1000000000000000),
		Signature: []*felt.Felt{},
	}

	txHashV0, err := accnt.TransactionHashInvoke(invokeTxnV0)
	if err != nil {
		log.Fatal("Failed to compute V0 hash:", err)
	}

	fmt.Printf("V0 Transaction (Deprecated):\n")
	fmt.Printf("  Contract:   %s\n", invokeTxnV0.ContractAddress.String())
	fmt.Printf("  EntryPoint: %s\n", invokeTxnV0.EntryPointSelector.String())
	fmt.Printf("  Hash:       %s\n", txHashV0.String())
}
```

:::note
Create a `.env` file in your project root and add `STARKNET_RPC_URL`, `ACCOUNT_ADDRESS`, `ACCOUNT_PUBLIC_KEY`, and `ACCOUNT_PRIVATE_KEY` variables and also install required packages like `godotenv` as you see in the usage example above.
:::

## Error Handling

```go
txHash, err := accnt.TransactionHashInvoke(invokeTx)
if err != nil {
	// Handle hash calculation errors
	return err
}
```

## Common Use Cases

- Computing transaction hash before signing invoke transactions
- Verifying transaction hash matches expected value
- Low-level transaction hash computation for debugging
- Manual signing workflows requiring separate hash calculation
- Usually handled automatically by SignInvokeTransaction method
