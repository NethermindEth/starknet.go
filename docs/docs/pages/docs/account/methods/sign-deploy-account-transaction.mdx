# SignDeployAccountTransaction

Signs a deploy account transaction using the account's private key. This method computes the transaction hash based on the deploy account version, signs it, and attaches the signature to the transaction, making it ready for broadcasting.

## Method Signature

```go
func (account *Account) SignDeployAccountTransaction(
	ctx context.Context,
	tx rpc.DeployAccountType,
	precomputeAddress *felt.Felt,
) error
```

**Source:** [signature.go:L104-L127](https://github.com/NethermindEth/starknet.go/blob/main/account/signature.go#L104-L127)

## Parameters

- `ctx` - Context for cancellation and timeout
- `tx` - Deploy account transaction to sign
- `precomputeAddress` - Precomputed account address

## Returns

- `error` - Error if signing fails

## Usage Example

```go
package main

import (
	"context"
	"fmt"
	"log"
	"math/big"
	"os"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/account"
	"github.com/NethermindEth/starknet.go/contracts"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/NethermindEth/starknet.go/utils"
	"github.com/joho/godotenv"
)

func main() {
	ctx := context.Background()

	if err := godotenv.Load(); err != nil {
		log.Fatal("Failed to load .env file:", err)
	}

	rpcURL := os.Getenv("STARKNET_RPC_URL")
	if rpcURL == "" {
		log.Fatal("STARKNET_RPC_URL not set in .env file")
	}

	provider, err := rpc.NewProvider(ctx, rpcURL)
	if err != nil {
		log.Fatal("Failed to create provider:", err)
	}

	accountAddress := os.Getenv("ACCOUNT_ADDRESS")
	publicKey := os.Getenv("ACCOUNT_PUBLIC_KEY")
	privateKey := os.Getenv("ACCOUNT_PRIVATE_KEY")

	if accountAddress == "" || publicKey == "" || privateKey == "" {
		log.Fatal("ACCOUNT_ADDRESS, ACCOUNT_PUBLIC_KEY, or ACCOUNT_PRIVATE_KEY not set")
	}

	ks := account.NewMemKeystore()
	privKeyBI, ok := new(big.Int).SetString(privateKey, 0)
	if !ok {
		log.Fatal("Failed to parse private key")
	}
	ks.Put(publicKey, privKeyBI)

	classHash, _ := utils.HexToFelt("0x036078334509b514626504edc9fb252328d1a240e4e948bef8d0c08dff45927f")
	salt := new(felt.Felt).SetUint64(12345)
	newAccountPubKey, _ := utils.HexToFelt("0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef")
	constructorCalldata := []*felt.Felt{newAccountPubKey}

	precomputedAddress := contracts.PrecomputeAddress(
		new(felt.Felt).SetUint64(0),
		salt,
		classHash,
		constructorCalldata,
	)

	fmt.Printf("Class Hash:       %s\n", classHash.String())
	fmt.Printf("Salt:             %s\n", salt.String())
	fmt.Printf("Public Key:       %s\n", newAccountPubKey.String())
	fmt.Printf("Precomputed Addr: %s\n\n", precomputedAddress.String())

	deployTxn := &rpc.DeployAccountTxnV3{
		Type:                rpc.TransactionTypeDeployAccount,
		Version:             rpc.TransactionV3,
		Nonce:               new(felt.Felt).SetUint64(0),
		ClassHash:           classHash,
		ContractAddressSalt: salt,
		ConstructorCalldata: constructorCalldata,
		ResourceBounds: &rpc.ResourceBoundsMapping{
			L1Gas: rpc.ResourceBounds{
				MaxAmount:       "0x0",
				MaxPricePerUnit: "0x0",
			},
			L1DataGas: rpc.ResourceBounds{
				MaxAmount:       "0x0",
				MaxPricePerUnit: "0x0",
			},
			L2Gas: rpc.ResourceBounds{
				MaxAmount:       "0x0",
				MaxPricePerUnit: "0x0",
			},
		},
		Tip:           "0x0",
		PayMasterData: []*felt.Felt{},
		NonceDataMode: rpc.DAModeL1,
		FeeMode:       rpc.DAModeL1,
		Signature:     []*felt.Felt{},
	}

	fmt.Printf("Nonce:            %d\n", deployTxn.Nonce.Uint64())
	fmt.Printf("Signature (before): %v\n\n", deployTxn.Signature)

	newAcctKs := account.NewMemKeystore()
	newPrivKey := new(big.Int).SetBytes([]byte("temp_private_key_for_demo"))
	newAcctKs.Put(newAccountPubKey.String(), newPrivKey)

	newAcct, err := account.NewAccount(
		provider,
		precomputedAddress,
		newAccountPubKey.String(),
		newAcctKs,
		account.CairoV2,
	)
	if err != nil {
		log.Fatal("Failed to create new account instance:", err)
	}

	err = newAcct.SignDeployAccountTransaction(ctx, deployTxn, precomputedAddress)
	if err != nil {
		log.Fatal("Failed to sign deploy account transaction:", err)
	}

	fmt.Printf("Signature components:\n")
	fmt.Printf("  r: %s\n", deployTxn.Signature[0].String())
	fmt.Printf("  s: %s\n", deployTxn.Signature[1].String())
}
```

:::note
Create a `.env` file in your project root and add `STARKNET_RPC_URL`, `ACCOUNT_ADDRESS`, `ACCOUNT_PUBLIC_KEY`, and `ACCOUNT_PRIVATE_KEY` variables and also install required packages like `godotenv` as you see in the usage example above.
:::

## Error Handling

```go
err := accnt.SignDeployAccountTransaction(ctx, deployAccountTx, precomputedAddress)
if err != nil {
	// Handle signing errors
	return err
}
```

## Common Use Cases

- Manual signing workflow when building deploy account transactions from scratch
- Custom fee estimation logic requiring separate signing steps
- Multi-signature coordination where signatures need to be collected independently
- Testing and debugging deploy account transaction flows
- Advanced workflows requiring fine-grained control over transaction construction and signing
