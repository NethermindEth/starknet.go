# WaitForTransactionReceipt

Waits for a transaction to be confirmed on-chain.

## Method Signature

```go
func (account *Account) WaitForTransactionReceipt(
	ctx context.Context,
	transactionHash *felt.Felt,
	pollInterval time.Duration,
) (*rpc.TransactionReceiptWithBlockInfo, error)
```

## Parameters

- `ctx` - Context for cancellation and timeout
- `transactionHash` - Hash of transaction to wait for
- `pollInterval` - Time between status checks

## Returns

- `*rpc.TransactionReceiptWithBlockInfo` - Transaction receipt with block info
- `error` - Error if waiting fails or context cancelled

## Usage Example

> **Prerequisites**: This example assumes you have a funded and deployed account instance. To learn how to create an account, see [NewAccount](./new-account.mdx).

```go
package main

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/account"
	"github.com/NethermindEth/starknet.go/rpc"
)

func main() {
	// Assuming 'acc' is your Account instance (funded and deployed)
	var acc *account.Account
	// acc = ... (already initialized)

	// First, send a transaction
	ethContract, _ := new(felt.Felt).SetString("0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7")

	functionCall := rpc.InvokeFunctionCall{
		ContractAddress: ethContract,
		FunctionName:    "transfer",
		CallData: []*felt.Felt{
			acc.Address,                 // recipient
			new(felt.Felt).SetUint64(1), // amount
			new(felt.Felt).SetUint64(0),
		},
	}

	ctx := context.Background()
	response, err := acc.BuildAndSendInvokeTxn(ctx, []rpc.InvokeFunctionCall{functionCall}, nil)
	if err != nil {
		log.Fatalf("Error sending transaction: %v", err)
	}

	fmt.Printf("Transaction Hash: %s\n", response.Hash)
	fmt.Println("Waiting for confirmation...")

	// Wait for receipt (poll every 2 seconds)
	receipt, err := acc.WaitForTransactionReceipt(
		ctx,
		response.Hash,
		2*time.Second,
	)
	if err != nil {
		log.Fatalf("Error waiting for receipt: %v", err)
	}

	fmt.Println("✅ Transaction confirmed!")
	fmt.Printf("Block Number: %d\n", receipt.BlockNumber)
	fmt.Printf("Execution Status: %s\n", receipt.ExecutionStatus)
	fmt.Printf("Finality Status: %s\n", receipt.FinalityStatus)
}
```

## Expected Output

```
Transaction Hash: 0x4bdcc9d9c3d512652fbf7c5ad6ab3d2a7add39acac1bde1c0f2341c968d02ee
Waiting for confirmation...
✅ Transaction confirmed!
Block Number: 2838869
Execution Status: SUCCEEDED
Finality Status: PRE_CONFIRMED
```

**View on Explorer:**
- [Voyager](https://sepolia.voyager.online/tx/0x4bdcc9d9c3d512652fbf7c5ad6ab3d2a7add39acac1bde1c0f2341c968d02ee) - View transaction details
- [Starkscan](https://sepolia.starkscan.co/tx/0x4bdcc9d9c3d512652fbf7c5ad6ab3d2a7add39acac1bde1c0f2341c968d02ee) - Alternative explorer

## Usage with Timeout

```go
// Wait with timeout
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
defer cancel()

receipt, err := acc.WaitForTransactionReceipt(
	ctx,
	transactionHash,
	3*time.Second,
)
if err != nil {
	if err == context.DeadlineExceeded {
		fmt.Println("Transaction confirmation timed out")
	}
	return err
}
```

## Description

WaitForTransactionReceipt polls the network at regular intervals until the transaction is confirmed or the context is cancelled. It handles the "transaction not found" case gracefully and continues polling.

## Error Handling

```go
receipt, err := acc.WaitForTransactionReceipt(ctx, txHash, pollInterval)
if err != nil {
	// Handle errors like:
	// - Context cancelled
	// - Context deadline exceeded
	// - Network errors
	return err
}

// Check execution status
switch receipt.ExecutionStatus {
case rpc.TxnExecutionStatusSUCCEEDED:
	fmt.Println("Transaction succeeded")
case rpc.TxnExecutionStatusREVERTED:
	fmt.Println("Transaction reverted")
}
```

## Related Methods

- [BuildAndSendInvokeTxn](./build-and-send-invoke-txn.mdx) - Send transactions
- [TransactionReceipt](../../rpc/methods/transaction-receipt.mdx) - Get receipt without waiting
