# WaitForTransactionReceipt

Waits for a transaction to be confirmed on-chain. This method polls the network at regular intervals until the transaction is confirmed or the context is cancelled, handling the "transaction not found" case gracefully by continuing to poll.

## Method Signature

```go
func (account *Account) WaitForTransactionReceipt(
	ctx context.Context,
	transactionHash *felt.Felt,
	pollInterval time.Duration,
) (*rpc.TransactionReceiptWithBlockInfo, error)
```

**Source:** [account.go](https://github.com/NethermindEth/starknet.go/blob/main/account/account.go)

## Parameters

- `ctx` - Context for cancellation and timeout
- `transactionHash` - Hash of transaction to wait for
- `pollInterval` - Time between status checks

## Returns

- `*rpc.TransactionReceiptWithBlockInfo` - Transaction receipt with block info
- `error` - Error if waiting fails or context cancelled

## Usage Example

```go
package main

import (
	"context"
	"fmt"
	"log"
	"math/big"
	"os"
	"time"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/account"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/NethermindEth/starknet.go/utils"
	"github.com/joho/godotenv"
)

func main() {
	ctx := context.Background()

	if err := godotenv.Load(); err != nil {
		log.Fatal("Failed to load .env file:", err)
	}

	rpcURL := os.Getenv("STARKNET_RPC_URL")
	if rpcURL == "" {
		log.Fatal("STARKNET_RPC_URL not set")
	}

	provider, err := rpc.NewProvider(ctx, rpcURL)
	if err != nil {
		log.Fatal("Failed to create provider:", err)
	}

	accountAddress := os.Getenv("ACCOUNT_ADDRESS")
	publicKey := os.Getenv("ACCOUNT_PUBLIC_KEY")
	privateKey := os.Getenv("ACCOUNT_PRIVATE_KEY")

	if accountAddress == "" || publicKey == "" || privateKey == "" {
		log.Fatal("Account credentials not set in .env")
	}

	ks := account.NewMemKeystore()
	privKeyBI, ok := new(big.Int).SetString(privateKey, 0)
	if !ok {
		log.Fatal("Failed to parse private key")
	}
	ks.Put(publicKey, privKeyBI)

	accountAddressFelt, err := utils.HexToFelt(accountAddress)
	if err != nil {
		log.Fatal("Failed to parse account address:", err)
	}

	accnt, err := account.NewAccount(provider, accountAddressFelt, publicKey, ks, account.CairoV2)
	if err != nil {
		log.Fatal("Failed to create account:", err)
	}

	strkContract, _ := utils.HexToFelt("0x04718f5a0fc34cc1af16a1cdee98ffb20c31f5cd61d6ab07201858f4287c938d")
	recipient := accountAddressFelt
	amount := new(felt.Felt).SetUint64(1000000000000000)
	u256Amount, _ := utils.HexToU256Felt(amount.String())

	invokeFnCall := rpc.InvokeFunctionCall{
		ContractAddress: strkContract,
		FunctionName:    "transfer",
		CallData:        append([]*felt.Felt{recipient}, u256Amount...),
	}

	tx, err := accnt.BuildAndSendInvokeTxn(ctx, []rpc.InvokeFunctionCall{invokeFnCall}, nil)
	if err != nil {
		log.Fatal("Failed to send transaction:", err)
	}

	fmt.Printf("Transaction sent: %s\n", tx.Hash.String())

	receipt, err := accnt.WaitForTransactionReceipt(ctx, tx.Hash, 3*time.Second)
	if err != nil {
		log.Fatal("Failed to get receipt:", err)
	}

	fmt.Printf("Block Hash: %s\n", receipt.BlockHash.String())
	fmt.Printf("Block Number: %d\n", receipt.BlockNumber)
	fmt.Printf("Status: %s\n", receipt.FinalityStatus)
}
```

:::note
Create a `.env` file in your project root and add `STARKNET_RPC_URL`, `ACCOUNT_ADDRESS`, `ACCOUNT_PUBLIC_KEY`, and `ACCOUNT_PRIVATE_KEY` variables and also install required packages like `godotenv` as you see in the usage example above.
:::

## Error Handling

```go
receipt, err := accnt.WaitForTransactionReceipt(ctx, txHash, pollInterval)
if err != nil {
	// Handle errors
	return err
}

switch receipt.ExecutionStatus {
case rpc.TxnExecutionStatusSUCCEEDED:
	fmt.Println("Transaction succeeded")
case rpc.TxnExecutionStatusREVERTED:
	fmt.Println("Transaction reverted")
}
```

## Common Use Cases

- Waiting for transaction confirmation before proceeding with dependent operations
- Monitoring transaction status in automated workflows
- Ensuring transaction finality before updating application state
- Implementing retry logic based on transaction execution status
- Building transaction monitoring and notification systems
