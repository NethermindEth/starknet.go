# SignInvokeTransaction

Signs an invoke transaction.

## Method Signature

```go
func (account *Account) SignInvokeTransaction(
	ctx context.Context,
	invokeTx rpc.InvokeTxnType,
) error
```

## Parameters

- `ctx` - Context for cancellation and timeout
- `invokeTx` - Invoke transaction to sign (V0, V1, or V3)

## Returns

- `error` - Error if signing fails

## Usage Example

> **Prerequisites**: This example assumes you have an account instance already created. To learn how to create an account, see [NewAccount](./new-account.mdx).

```go
package main

import (
	"context"
	"fmt"
	"log"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/account"
	"github.com/NethermindEth/starknet.go/rpc"
)

func main() {
	// Assuming 'acc' is your Account instance
	var acc *account.Account
	// acc = ... (already initialized)

	// Create an invoke transaction V1
	accountAddress, _ := new(felt.Felt).SetString("0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7")
	contractAddress, _ := new(felt.Felt).SetString("0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7")
	entryPointSelector, _ := new(felt.Felt).SetString("0x83afd3f4caedc6eebf44246fe54e38c95e3179a5ec9ea81740eca5b482d12e")
	recipient, _ := new(felt.Felt).SetString("0x1234567890abcdef")

	invokeTx := &rpc.InvokeTxnV1{
		Type:          rpc.TransactionTypeInvoke,
		SenderAddress: accountAddress,
		Nonce:         new(felt.Felt).SetUint64(0),
		MaxFee:        new(felt.Felt).SetUint64(1000000000000),
		Version:       rpc.TransactionV1,
		Signature:     []*felt.Felt{}, // Empty before signing
		Calldata: []*felt.Felt{
			new(felt.Felt).SetUint64(1), // num calls
			contractAddress,
			entryPointSelector,
			new(felt.Felt).SetUint64(3), // calldata len
			recipient,
			new(felt.Felt).SetUint64(100), // amount
			new(felt.Felt).SetUint64(0),   // amount high
		},
	}

	fmt.Printf("Before signing - Signature length: %d\n", len(invokeTx.Signature))

	// Sign the transaction
	ctx := context.Background()
	err := acc.SignInvokeTransaction(ctx, invokeTx)
	if err != nil {
		log.Fatalf("Error signing transaction: %v", err)
	}

	fmt.Printf("After signing - Signature length: %d\n", len(invokeTx.Signature))
	for i, sig := range invokeTx.Signature {
		fmt.Printf("Signature[%d]: %s\n", i, sig)
	}
}
```

## Expected Output

```
Before signing - Signature length: 0
After signing - Signature length: 2
Signature[0]: 0x5258e0774fcc97c2dc830b0119a83c301f86707fc9541941a1cda984e0ca5fb
Signature[1]: 0x5c5e86aadb169eb8850ed2434fb6bb973051feaf17c8e9bf1421e3f97b1c8a6
```

## Description

SignInvokeTransaction calculates the transaction hash and signs it, setting the Signature field on the transaction. Supports V0, V1, and V3 transactions.

Typically, you don't call this directly. Use BuildAndSendInvokeTxn which handles signing automatically.

## Error Handling

```go
err := acc.SignInvokeTransaction(ctx, tx)
if err != nil {
	// Handle errors like:
	// - Invalid transaction type
	// - Hash calculation failure
	// - Signing failure
	return err
}
```

## Related Methods

- [BuildAndSendInvokeTxn](./build-and-send-invoke-txn.mdx) - High-level invoke method
- [TransactionHashInvoke](./transaction-hash-invoke.mdx) - Calculate transaction hash
- [Sign](./sign.mdx) - Low-level signing
