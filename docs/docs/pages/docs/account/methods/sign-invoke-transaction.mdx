# SignInvokeTransaction

Signs an invoke transaction using the account's private key. This method computes the transaction hash based on the invoke version, signs it, and attaches the signature to the transaction, making it ready for broadcasting. Supports V0, V1, and V3 invoke transactions.

## Method Signature

```go
func (account *Account) SignInvokeTransaction(
	ctx context.Context,
	invokeTx rpc.InvokeTxnType,
) error
```

**Source:** [signature.go:L36-L75](https://github.com/NethermindEth/starknet.go/blob/main/account/signature.go#L36-L75)

## Parameters

- `ctx` - Context for cancellation and timeout
- `invokeTx` - Invoke transaction to sign (V0, V1, or V3)

## Returns

- `error` - Error if signing fails

## Usage Example

```go
package main

import (
	"context"
	"fmt"
	"log"
	"math/big"
	"os"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/account"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/NethermindEth/starknet.go/utils"
	"github.com/joho/godotenv"
)

func main() {
	ctx := context.Background()

	if err := godotenv.Load(); err != nil {
		log.Fatal("Failed to load .env file:", err)
	}

	rpcURL := os.Getenv("STARKNET_RPC_URL")
	if rpcURL == "" {
		log.Fatal("STARKNET_RPC_URL not set in .env file")
	}

	provider, err := rpc.NewProvider(ctx, rpcURL)
	if err != nil {
		log.Fatal("Failed to create provider:", err)
	}

	accountAddress := os.Getenv("ACCOUNT_ADDRESS")
	publicKey := os.Getenv("ACCOUNT_PUBLIC_KEY")
	privateKey := os.Getenv("ACCOUNT_PRIVATE_KEY")

	if accountAddress == "" || publicKey == "" || privateKey == "" {
		log.Fatal("ACCOUNT_ADDRESS, ACCOUNT_PUBLIC_KEY, or ACCOUNT_PRIVATE_KEY not set")
	}

	ks := account.NewMemKeystore()
	privKeyBI, ok := new(big.Int).SetString(privateKey, 0)
	if !ok {
		log.Fatal("Failed to parse private key")
	}
	ks.Put(publicKey, privKeyBI)

	accountAddressFelt, err := utils.HexToFelt(accountAddress)
	if err != nil {
		log.Fatal("Failed to parse account address:", err)
	}

	accnt, err := account.NewAccount(
		provider,
		accountAddressFelt,
		publicKey,
		ks,
		account.CairoV2,
	)
	if err != nil {
		log.Fatal("Failed to create account:", err)
	}

	nonce, err := accnt.Nonce(ctx)
	if err != nil {
		log.Fatal("Failed to get nonce:", err)
	}

	strkContract, _ := utils.HexToFelt("0x04718f5a0fc34cc1af16a1cdee98ffb20c31f5cd61d6ab07201858f4287c938d")
	recipient := accountAddressFelt
	amount := new(felt.Felt).SetUint64(1000000000000000)
	u256Amount, _ := utils.HexToU256Felt(amount.String())

	fnCall := rpc.FunctionCall{
		ContractAddress:    strkContract,
		EntryPointSelector: utils.GetSelectorFromNameFelt("transfer"),
		Calldata:           append([]*felt.Felt{recipient}, u256Amount...),
	}

	calldata, err := accnt.FmtCalldata([]rpc.FunctionCall{fnCall})
	if err != nil {
		log.Fatal("Failed to format calldata:", err)
	}

	invokeTx := utils.BuildInvokeTxn(
		accnt.Address,
		nonce,
		calldata,
		&rpc.ResourceBoundsMapping{
			L1Gas: rpc.ResourceBounds{
				MaxAmount:       "0x0",
				MaxPricePerUnit: "0x0",
			},
			L1DataGas: rpc.ResourceBounds{
				MaxAmount:       "0x0",
				MaxPricePerUnit: "0x0",
			},
			L2Gas: rpc.ResourceBounds{
				MaxAmount:       "0x0",
				MaxPricePerUnit: "0x0",
			},
		},
		nil,
	)

	fmt.Printf("Sender:             %s\n", invokeTx.SenderAddress.String())
	fmt.Printf("Nonce:              %d\n", invokeTx.Nonce.Uint64())
	fmt.Printf("Calldata:           %d elements\n", len(invokeTx.Calldata))
	fmt.Printf("Signature (before): %v\n\n", invokeTx.Signature)

	err = accnt.SignInvokeTransaction(ctx, invokeTx)
	if err != nil {
		log.Fatal("Failed to sign invoke transaction:", err)
	}

	fmt.Printf("Signature components:\n")
	fmt.Printf("  r: %s\n", invokeTx.Signature[0].String())
	fmt.Printf("  s: %s\n", invokeTx.Signature[1].String())
}
```

:::note
Create a `.env` file in your project root and add `STARKNET_RPC_URL`, `ACCOUNT_ADDRESS`, `ACCOUNT_PUBLIC_KEY`, and `ACCOUNT_PRIVATE_KEY` variables and also install required packages like `godotenv` as you see in the usage example above.
:::

## Error Handling

```go
err := accnt.SignInvokeTransaction(ctx, invokeTx)
if err != nil {
	// Handle signing errors
	return err
}
```

## Common Use Cases

- Manual transaction building workflow with custom fee estimation logic
- Multi-signature coordination where signatures need to be collected independently
- Testing and debugging invoke transaction flows
- Advanced workflows requiring fine-grained control over transaction construction
- Inspecting transactions before sending them to the network
