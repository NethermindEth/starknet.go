# BuildAndSendInvokeTxn

Builds, signs, and sends an invoke transaction to execute contract functions.

## Method Signature

```go
func (account *Account) BuildAndSendInvokeTxn(
	ctx context.Context,
	functionCalls []rpc.InvokeFunctionCall,
	opts *TxnOptions,
) (rpc.AddInvokeTransactionResponse, error)
```

## Parameters

- `ctx` - Context for request cancellation and timeout
- `functionCalls` - Slice of function calls to execute
- `opts` - Transaction options (fee, multiplier, etc.). Pass `nil` for defaults

## Returns

- `rpc.AddInvokeTransactionResponse` - Transaction response with hash
- `error` - Error if transaction fails

## Usage Example

> **Prerequisites**: This example assumes you have a funded and deployed account instance. To learn how to create an account, see [NewAccount](./new-account.mdx).

```go
package main

import (
	"context"
	"fmt"
	"log"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/account"
	"github.com/NethermindEth/starknet.go/rpc"
)

func main() {
	// Assuming 'acc' is your Account instance (funded and deployed)
	var acc *account.Account
	// acc = ... (already initialized)

	// Example: Transfer 1 wei ETH to ourselves
	// ETH token contract on Starknet Sepolia
	ethContract, _ := new(felt.Felt).SetString("0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7")

	// Get account address as recipient
	recipient := acc.Address

	functionCall := rpc.InvokeFunctionCall{
		ContractAddress: ethContract,
		FunctionName:    "transfer",
		CallData: []*felt.Felt{
			recipient,                   // recipient
			new(felt.Felt).SetUint64(1), // amount (u256 low)
			new(felt.Felt).SetUint64(0), // amount (u256 high)
		},
	}

	// Send transaction with default options
	ctx := context.Background()
	response, err := acc.BuildAndSendInvokeTxn(ctx, []rpc.InvokeFunctionCall{functionCall}, nil)
	if err != nil {
		log.Fatalf("Error sending transaction: %v", err)
	}

	fmt.Printf("✅ Transaction sent!\n")
	fmt.Printf("Transaction Hash: %s\n", response.Hash)
}
```

## Expected Output

```
✅ Transaction sent!
Transaction Hash: 0x637e8d80050fd18192c250b3cac4c84ed0b19234cefe5f952d8e73666e50b13
```

**View on Explorer:**
- [Voyager](https://sepolia.voyager.online/tx/0x637e8d80050fd18192c250b3cac4c84ed0b19234cefe5f952d8e73666e50b13) - Starknet block explorer
- [Starkscan](https://sepolia.starkscan.co/tx/0x637e8d80050fd18192c250b3cac4c84ed0b19234cefe5f952d8e73666e50b13) - Alternative explorer

## Transaction Options

Configure transaction behavior with TxnOptions:

```go
opts := &account.TxnOptions{
	Multiplier:     1.5,    // 50% safety margin for fees
	UseLatest:      false,  // Use pre_confirmed block for estimation
	UseQueryBit:    false,  // Use normal transaction version
	SimulationFlag: rpc.SkipValidate, // Skip validation during simulation
}

response, err := acc.BuildAndSendInvokeTxn(context.Background(), functionCalls, opts)
```

## Description

BuildAndSendInvokeTxn handles the complete flow of executing a transaction:

1. Fetches current nonce
2. Formats calldata based on Cairo version
3. Creates transaction with zero fees
4. Signs transaction for fee estimation
5. Estimates fees
6. Updates transaction with estimated fees (applying multiplier)
7. Signs transaction again with final fees
8. Sends transaction to network

All steps are handled automatically.

## Error Handling

```go
response, err := acc.BuildAndSendInvokeTxn(ctx, functionCalls, opts)
if err != nil {
	// Handle errors like:
	// - Insufficient balance
	// - Invalid function calls
	// - Network errors
	// - Fee estimation failure
	return err
}
```

## Related Methods

- [SignInvokeTransaction](./sign-invoke-transaction.mdx) - Sign invoke transactions
- [SendTransaction](./send-transaction.mdx) - Send pre-built transactions
- [WaitForTransactionReceipt](./wait-for-transaction-receipt.mdx) - Wait for confirmation
- [FmtCalldata](./fmt-calldata.mdx) - Format calldata for invoke transactions
