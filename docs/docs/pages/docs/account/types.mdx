# Account Types

Type definitions and structures used in the account package.

## Account

Main structure representing a Starknet account.

### Type Definition

```go
type Account struct {
	Provider     rpc.RPCProvider
	ChainID      *felt.Felt
	Address      *felt.Felt
	CairoVersion CairoVersion
	// contains filtered or unexported fields
}
```

### Fields

#### Provider
```go
Provider rpc.RPCProvider
```
RPC provider used to interact with the Starknet network. This handles all network communication for the account.

#### ChainID
```go
ChainID *felt.Felt
```
Chain ID of the Starknet network. Automatically set during account creation:
- Mainnet: `SN_MAIN`
- Sepolia Testnet: `SN_SEPOLIA`

Used in transaction hash calculations to prevent replay attacks across different networks.

#### Address
```go
Address *felt.Felt
```
On-chain address of the account contract. This is the deployed account contract's address that executes transactions.

#### CairoVersion
```go
CairoVersion CairoVersion
```
Cairo version of the account contract (CairoV0 or CairoV2). Determines how calldata is formatted for transactions.

### Usage Example

```go
package main

import (
	"context"
	"fmt"
	"log"

	"github.com/NethermindEth/starknet.go/account"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/NethermindEth/starknet.go/utils"
)

func main() {
	// Create provider
	provider, err := rpc.NewProvider("https://starknet-sepolia.public.blastapi.io/rpc/v0_8")
	if err != nil {
		log.Fatal(err)
	}

	// Generate keys
	ks, pubKey, _ := account.GetRandomKeys()

	// Create account
	accountAddress, _ := utils.HexToFelt("0x1234...")
	acc, err := account.NewAccount(provider, accountAddress, pubKey.String(), ks, account.CairoV2)
	if err != nil {
		log.Fatal(err)
	}

	// Access account fields
	fmt.Printf("Address: %s\n", acc.Address.String())
	fmt.Printf("Chain ID: %s\n", acc.ChainID.String())
	fmt.Printf("Cairo Version: %d\n", acc.CairoVersion)

	// Use account
	nonce, err := acc.Nonce(context.Background())
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("Nonce: %s\n", nonce.String())
}
```

### Description

The Account struct encapsulates all information needed to interact with a Starknet account contract. It provides methods for:
- Transaction building and sending
- Message signing and verification
- Nonce management
- Fee estimation

The struct contains unexported fields (private key reference through keystore) that are not directly accessible.

### Related Types

- [AccountInterface](#accountinterface) - Interface implemented by Account
- [Keystore](./keystore.mdx#keystore-interface) - Key management interface
- [CairoVersion](#cairoversion) - Cairo version enum

---

## AccountInterface

Interface defining the contract for account implementations.

### Interface Definition

```go
type AccountInterface interface {
	BuildAndEstimateDeployAccountTxn(
		ctx context.Context,
		salt *felt.Felt,
		classHash *felt.Felt,
		constructorCalldata []*felt.Felt,
		opts *TxnOptions,
	) (*rpc.BroadcastDeployAccountTxnV3, *felt.Felt, error)

	BuildAndSendInvokeTxn(
		ctx context.Context,
		functionCalls []rpc.InvokeFunctionCall,
		opts *TxnOptions,
	) (rpc.AddInvokeTransactionResponse, error)

	BuildAndSendDeclareTxn(
		ctx context.Context,
		casmClass *contracts.CasmClass,
		contractClass *contracts.ContractClass,
		opts *TxnOptions,
	) (rpc.AddDeclareTransactionResponse, error)

	DeployContractWithUDC(
		ctx context.Context,
		classHash *felt.Felt,
		constructorCalldata []*felt.Felt,
		txnOpts *TxnOptions,
		udcOpts *UDCOptions,
	) (rpc.AddInvokeTransactionResponse, *felt.Felt, error)

	Nonce(ctx context.Context) (*felt.Felt, error)

	SendTransaction(
		ctx context.Context,
		txn rpc.BroadcastTxn,
	) (rpc.TransactionResponse, error)

	Sign(ctx context.Context, msg *felt.Felt) ([]*felt.Felt, error)

	SignInvokeTransaction(ctx context.Context, tx rpc.InvokeTxnType) error

	SignDeployAccountTransaction(
		ctx context.Context,
		tx rpc.DeployAccountType,
		precomputeAddress *felt.Felt,
	) error

	SignDeclareTransaction(ctx context.Context, tx rpc.DeclareTxnType) error

	TransactionHashInvoke(invokeTxn rpc.InvokeTxnType) (*felt.Felt, error)

	TransactionHashDeployAccount(
		tx rpc.DeployAccountType,
		contractAddress *felt.Felt,
	) (*felt.Felt, error)

	TransactionHashDeclare(tx rpc.DeclareTxnType) (*felt.Felt, error)

	Verify(msgHash *felt.Felt, signature []*felt.Felt) (bool, error)

	WaitForTransactionReceipt(
		ctx context.Context,
		transactionHash *felt.Felt,
		pollInterval time.Duration,
	) (*rpc.TransactionReceiptWithBlockInfo, error)
}
```

### Description

AccountInterface defines the standard interface for Starknet account implementations. The Account type implements this interface.

This interface can be used to:
- Write functions that accept any account implementation
- Create mock accounts for testing
- Implement custom account types with different behavior

### Usage Example

```go
package main

import (
	"context"
	"fmt"

	"github.com/NethermindEth/starknet.go/account"
	"github.com/NethermindEth/starknet.go/rpc"
)

// Function accepting any account implementation
func GetAccountInfo(acc account.AccountInterface) error {
	nonce, err := acc.Nonce(context.Background())
	if err != nil {
		return err
	}

	fmt.Printf("Account nonce: %s\n", nonce.String())
	return nil
}

func main() {
	// Can pass any AccountInterface implementation
	var acc *account.Account // Standard account
	GetAccountInfo(acc)

	// Or a custom implementation
	// var customAcc account.AccountInterface = &CustomAccount{}
	// GetAccountInfo(customAcc)
}
```

### Implementing Custom Accounts

```go
package main

import (
	"context"
	"time"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/account"
	"github.com/NethermindEth/starknet.go/contracts"
	"github.com/NethermindEth/starknet.go/rpc"
)

// CustomAccount implements AccountInterface with custom behavior
type CustomAccount struct {
	*account.Account
	// Additional fields...
}

// Override methods as needed
func (ca *CustomAccount) BuildAndSendInvokeTxn(
	ctx context.Context,
	functionCalls []rpc.InvokeFunctionCall,
	opts *account.TxnOptions,
) (rpc.AddInvokeTransactionResponse, error) {
	// Custom logic before sending
	fmt.Println("Custom account sending transaction...")

	// Call base implementation or implement from scratch
	return ca.Account.BuildAndSendInvokeTxn(ctx, functionCalls, opts)
}

// Ensure CustomAccount implements AccountInterface
var _ account.AccountInterface = (*CustomAccount)(nil)
```

### Methods

See the [Methods documentation](./methods.mdx) for detailed information about each interface method.

### Related Types

- [Account](#account) - Standard implementation
- [TxnOptions](#txnoptions) - Transaction configuration

---

## CairoVersion

Enum representing Cairo contract versions.

### Type Definition

```go
type CairoVersion int

const (
	CairoV0 CairoVersion = 0
	CairoV2 CairoVersion = 2
)
```

### Constants

#### CairoV0
```go
const CairoV0 CairoVersion = 0
```
Represents Cairo 0 contracts. Uses the older calldata format with offsets.

#### CairoV2
```go
const CairoV2 CairoVersion = 2
```
Represents Cairo 2 contracts (also known as Cairo 1). Uses the simplified calldata format without offsets.

### Usage Example

```go
package main

import (
	"fmt"

	"github.com/NethermindEth/starknet.go/account"
)

func main() {
	// Create account with Cairo 2
	acc, err := account.NewAccount(provider, address, pubKey, ks, account.CairoV2)
	if err != nil {
		log.Fatal(err)
	}

	// Check Cairo version
	if acc.CairoVersion == account.CairoV0 {
		fmt.Println("Using Cairo 0 account")
	} else if acc.CairoVersion == account.CairoV2 {
		fmt.Println("Using Cairo 2 account")
	}

	// The account automatically formats calldata based on its version
	response, err := acc.BuildAndSendInvokeTxn(ctx, functionCalls, nil)
}
```

### Description

CairoVersion determines how the account formats calldata for transactions:

**Cairo 0 Format:**
- More complex structure with offsets
- Required for older account contracts
- Format: [call_array_len, call_array..., calldata_len, calldata...]

**Cairo 2 Format:**
- Simplified structure without offsets
- Used by modern account contracts
- Format: [calls_len, (contract, selector, data_len, data)...]

The Account methods automatically handle the correct format based on the CairoVersion field.

### Determining Your Account's Version

To determine which version your account uses:
1. Check your account contract's Cairo version
2. OpenZeppelin accounts from 0.7.0+ use Cairo 2
3. ArgentX accounts use Cairo 2
4. Older contracts may use Cairo 0

When in doubt, check your account contract's documentation or source code.

### Related Functions

- [FmtCallDataCairo0](./functions.mdx#fmtcalldatacairo0) - Format for Cairo 0
- [FmtCallDataCairo2](./functions.mdx#fmtcalldatacairo2) - Format for Cairo 2
- [Account.FmtCalldata](./methods.mdx#fmtcalldata) - Auto-format based on version

---

## TxnOptions

Configuration options for building and sending transactions.

### Type Definition

```go
type TxnOptions struct {
	Tip            rpc.U64
	UseQueryBit    bool
	Multiplier     float64
	UseLatest      bool
	SimulationFlag rpc.SimulationFlag
}
```

### Fields

#### Tip
```go
Tip rpc.U64
```
Tip amount in FRI (smallest unit of STRK) for transaction prioritization.

**Default:** `"0x0"` (no tip)

**Note:** Transaction tips are only active after Starknet v0.14.0 upgrade.

#### UseQueryBit
```go
UseQueryBit bool
```
Whether to use the query bit in transaction version during fee estimation.

**Values:**
- `true`: Uses version `0x100000000000000000000000000000003` (TransactionV3WithQueryBit)
- `false`: Uses version `0x3` (TransactionV3)

**Default:** `false`

**Usage:** Set to `false` unless you have specific needs for query bit transactions.

#### Multiplier
```go
Multiplier float64
```
Safety multiplier for fee estimation. Multiplies both max amount and max price per unit.

**Recommended:** `1.5` (50% safety margin)

**Default:** `1.5` if `<= 0`

**Examples:**
- `1.0`: No safety margin (risky)
- `1.5`: 50% safety margin (recommended)
- `2.0`: 100% safety margin (very safe, may overpay)

Higher values provide more safety against fee fluctuations but may result in overpayment.

#### UseLatest
```go
UseLatest bool
```
Whether to use the `latest` block tag for fee estimation instead of `pre_confirmed`.

**Values:**
- `true`: Use `latest` block
- `false`: Use `pre_confirmed` block

**Default:** `false`

**Usage:** Set to `true` if you need the most recent block state for estimation.

#### SimulationFlag
```go
SimulationFlag rpc.SimulationFlag
```
Simulation flag for fee estimation.

**Options:**
- `rpc.SkipValidate`: Skip validation during simulation
- `""`: No simulation flags (default)

**Default:** No flags (empty)

### Usage Example

```go
package main

import (
	"context"
	"log"

	"github.com/NethermindEth/starknet.go/account"
	"github.com/NethermindEth/starknet.go/rpc"
)

func main() {
	// Assume acc and functionCalls are already created
	var acc *account.Account
	var functionCalls []rpc.InvokeFunctionCall

	// Example 1: Use default options (nil)
	response, err := acc.BuildAndSendInvokeTxn(context.Background(), functionCalls, nil)
	if err != nil {
		log.Fatal(err)
	}

	// Example 2: Configure specific options
	opts := &account.TxnOptions{
		Tip:            "0x0",           // No tip
		UseQueryBit:    false,           // Standard version
		Multiplier:     1.5,             // 50% safety margin
		UseLatest:      false,           // Use pre_confirmed block
		SimulationFlag: rpc.SkipValidate, // Skip validation
	}

	response, err = acc.BuildAndSendInvokeTxn(context.Background(), functionCalls, opts)
	if err != nil {
		log.Fatal(err)
	}

	// Example 3: Conservative fee estimation
	conservativeOpts := &account.TxnOptions{
		Multiplier: 2.0, // 100% safety margin
		UseLatest:  true, // Use latest block
	}

	response, err = acc.BuildAndSendInvokeTxn(context.Background(), functionCalls, conservativeOpts)
}
```

### Methods

#### BlockID
```go
func (opts *TxnOptions) BlockID() rpc.BlockID
```
Returns the block ID for fee estimation based on UseLatest flag.

**Usage:**
```go
opts := &account.TxnOptions{UseLatest: true}
blockID := opts.BlockID() // Returns WithBlockTag("latest")
```

#### SimulationFlags
```go
func (opts *TxnOptions) SimulationFlags() []rpc.SimulationFlag
```
Returns simulation flags as a slice. Returns empty slice if no flags set.

**Usage:**
```go
opts := &account.TxnOptions{SimulationFlag: rpc.SkipValidate}
flags := opts.SimulationFlags() // Returns []rpc.SimulationFlag{rpc.SkipValidate}
```

### Default Behavior

When `opts` is `nil` or fields are not set:

```go
// These are equivalent:
acc.BuildAndSendInvokeTxn(ctx, calls, nil)

acc.BuildAndSendInvokeTxn(ctx, calls, &account.TxnOptions{
	Tip:            "0x0",
	UseQueryBit:    false,
	Multiplier:     1.5,
	UseLatest:      false,
	SimulationFlag: "",
})
```

### Fee Estimation Strategy

Choosing the right multiplier:

```go
// Low risk, predictable fees (testnet, low value)
opts := &account.TxnOptions{Multiplier: 1.2} // 20% safety

// Recommended for most cases
opts := &account.TxnOptions{Multiplier: 1.5} // 50% safety

// High risk or volatile fees (mainnet, high value)
opts := &account.TxnOptions{Multiplier: 2.0} // 100% safety

// Maximum safety (critical transactions)
opts := &account.TxnOptions{Multiplier: 3.0} // 200% safety
```

### Related Methods

- [BuildAndSendInvokeTxn](./methods.mdx#buildandsendinvoketxn) - Uses TxnOptions
- [BuildAndSendDeclareTxn](./methods.mdx#buildandsenddeclaretxn) - Uses TxnOptions
- [BuildAndEstimateDeployAccountTxn](./methods.mdx#buildandestimatedeployaccounttxn) - Uses TxnOptions
- [DeployContractWithUDC](./methods.mdx#deploycontractwithudc) - Uses TxnOptions

---

## UDCOptions

Configuration options for Universal Deployer Contract (UDC) deployments.

### Type Definition

```go
type UDCOptions = utils.UDCOptions
```

This is an alias for `utils.UDCOptions`. See the [utils package documentation](../utilities/types.mdx) for complete details.

### Fields

Based on the utils package, UDCOptions typically includes:

```go
type UDCOptions struct {
	Salt   *felt.Felt // Salt for address computation
	Unique bool       // Whether to make address unique to deployer
}
```

#### Salt
Random value used in contract address computation. If not provided, a random salt is generated.

#### Unique
If `true`, includes the deployer address in address calculation, making the deployed address unique to the deployer. If `false`, anyone can deploy to the same address with the same parameters.

### Usage Example

```go
package main

import (
	"context"
	"fmt"
	"log"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/account"
	"github.com/NethermindEth/starknet.go/utils"
)

func main() {
	// Assume acc is already created
	var acc *account.Account
	var classHash *felt.Felt
	var constructorCalldata []*felt.Felt

	// Example 1: Use default options (random salt, unique=true)
	response, salt, err := acc.DeployContractWithUDC(
		context.Background(),
		classHash,
		constructorCalldata,
		nil, // Transaction options
		nil, // UDC options - will use defaults
	)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("Deployed with random salt: %s\n", salt.String())

	// Example 2: Specify custom salt
	udcOpts := &utils.UDCOptions{
		Salt:   new(felt.Felt).SetUint64(42),
		Unique: true,
	}

	response, salt, err = acc.DeployContractWithUDC(
		context.Background(),
		classHash,
		constructorCalldata,
		nil,
		udcOpts,
	)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("Deployed with custom salt: %s\n", salt.String())

	// Example 3: Non-unique deployment (counterfactual address)
	nonUniqueOpts := &utils.UDCOptions{
		Salt:   new(felt.Felt).SetUint64(123),
		Unique: false, // Anyone can deploy to this address
	}

	response, salt, err = acc.DeployContractWithUDC(
		context.Background(),
		classHash,
		constructorCalldata,
		nil,
		nonUniqueOpts,
	)
}
```

### Description

UDCOptions configures how contracts are deployed through the Universal Deployer Contract:

**Random Salt (nil options):**
- Generates random salt
- Unique to deployer
- Address cannot be predicted beforehand

**Custom Salt + Unique:**
- Predictable address
- Unique to deployer
- Prevents others from deploying to same address

**Custom Salt + Non-Unique:**
- Counterfactual address
- Same for all deployers with same parameters
- Allows CREATE2-style deployments

### Calculating Deployed Address

```go
// After deployment, calculate the address
deployedAddress := utils.CalculateUDCAddress(
	classHash,
	salt,
	constructorCalldata,
	acc.Address, // Include if Unique: true
)
fmt.Printf("Contract deployed at: %s\n", deployedAddress.String())
```

### Related Methods

- [DeployContractWithUDC](./methods.mdx#deploycontractwithudc) - Deploy with UDC
- [BuildUDCCalldata](../utilities/common.mdx) - Build UDC calldata manually

---

## Error Types

Common errors returned by account methods.

### ErrTxnTypeUnSupported

```go
var ErrTxnTypeUnSupported = errors.New("unsupported transaction type")
```

Returned when an unsupported transaction type is passed to a method.

**Example:**
```go
hash, err := acc.TransactionHashInvoke(invalidTxType)
if err != nil {
	if errors.Is(err, account.ErrTxnTypeUnSupported) {
		fmt.Println("Transaction type not supported")
	}
}
```

### ErrTxnVersionUnSupported

```go
var ErrTxnVersionUnSupported = errors.New("unsupported transaction version")
```

Returned when an unsupported transaction version is used.

**Example:**
```go
hash, err := acc.TransactionHashDeclare(declareTxnV0)
if err != nil {
	if errors.Is(err, account.ErrTxnVersionUnSupported) {
		fmt.Println("Declare V0 hash calculation not supported")
	}
}
```

### ErrSenderNoExist

```go
var ErrSenderNoExist = errors.New("sender does not exist")
```

Returned by MemKeystore.Get when a key is not found.

**Example:**
```go
key, err := ks.Get(publicKey)
if err != nil {
	if errors.Is(err, account.ErrSenderNoExist) {
		fmt.Println("Key not found in keystore")
	}
}
```

## Related Resources

- [Account Methods](./methods.mdx) - Methods using these types
- [Account Functions](./functions.mdx) - Functions working with types
- [Keystore](./keystore.mdx) - Key management types
- [RPC Types](../rpc/index.mdx) - RPC-related types
