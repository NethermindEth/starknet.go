# Contracts Examples

This page provides comprehensive examples for working with the Contracts package, covering common patterns and use cases.

## Basic Contract Address Precomputation

Calculate where a contract will be deployed before actually deploying it.

```go
package main

import (
	"fmt"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/contracts"
)

func main() {
	// Set up deployment parameters
	deployerAddress, _ := new(felt.Felt).SetString("0x1234567890abcdef")
	salt, _ := new(felt.Felt).SetString("0x12345")
	classHash, _ := new(felt.Felt).SetString("0x07e2e0ba00c247e6c2c7e38e8cadfcc59f828bb94c182e69bd8ea667bcbb65e7")

	// Constructor calldata
	constructorCalldata := []*felt.Felt{
		new(felt.Felt).SetUint64(100),
		new(felt.Felt).SetUint64(200),
	}

	// Compute the contract address
	contractAddress := contracts.PrecomputeAddress(
		deployerAddress,
		salt,
		classHash,
		constructorCalldata,
	)

	fmt.Printf("Deployer Address: %s\n", deployerAddress.String())
	fmt.Printf("Salt: %s\n", salt.String())
	fmt.Printf("Class Hash: %s\n", classHash.String())
	fmt.Printf("Computed Contract Address: %s\n", contractAddress.String())
}
```

## Loading CASM Classes

Load and inspect compiled Cairo Assembly (CASM) contract classes.

```go
package main

import (
	"fmt"
	"log"

	"github.com/NethermindEth/starknet.go/contracts"
)

func main() {
	// Path to the compiled CASM file (generated by Scarb build process)
	casmPath := "counter_contract/target/dev/counter_Counter.compiled_contract_class.json"

	// Load CASM class from file
	casmClass, err := contracts.UnmarshalCasmClass(casmPath)
	if err != nil {
		log.Fatalf("Failed to load CASM class: %v", err)
	}

	// Display class information
	fmt.Printf("Compiler Version: %s\n", casmClass.CompilerVersion)
	fmt.Printf("Bytecode Length: %d instructions\n", len(casmClass.ByteCode))
	fmt.Printf("Prime: %s\n", casmClass.Prime)

	// Inspect entry points
	fmt.Printf("\nEntry Points:\n")
	fmt.Printf("  Constructors: %d\n", len(casmClass.EntryPointsByType.Constructor))
	fmt.Printf("  External: %d\n", len(casmClass.EntryPointsByType.External))
	fmt.Printf("  L1 Handlers: %d\n", len(casmClass.EntryPointsByType.L1Handler))

	// List external functions
	fmt.Println("\nExternal Functions:")
	for _, ep := range casmClass.EntryPointsByType.External {
		fmt.Printf("  Selector: %s, Offset: %d\n", ep.Selector.String(), ep.Offset)
	}
}
```

## Counterfactual Deployment Pattern

Deploy a contract to a predetermined address, useful for account abstraction and CREATE2-style patterns.

```go
package main

import (
	"fmt"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/contracts"
)

func main() {
	// Account and deployment parameters
	accountAddress, _ := new(felt.Felt).SetString("0x1234567890abcdef")
	classHash, _ := new(felt.Felt).SetString("0x07e2e0ba00c247e6c2c7e38e8cadfcc59f828bb94c182e69bd8ea667bcbb65e7")
	salt := new(felt.Felt).SetUint64(12345)
	constructorCalldata := []*felt.Felt{
		new(felt.Felt).SetUint64(1000), // initial_supply
	}

	// Precompute the contract address before deployment
	futureAddress := contracts.PrecomputeAddress(
		accountAddress,
		salt,
		classHash,
		constructorCalldata,
	)

	fmt.Printf("Contract will be deployed at: %s\n", futureAddress.String())
	fmt.Println("\nCounterfactual deployment workflow:")
	fmt.Println("1. Know the address before deployment")
	fmt.Println("2. Fund the address if needed for constructor")
	fmt.Println("3. Deploy the contract (it will appear at the precomputed address)")
}
```

## Factory Contract Pattern

Create multiple contract instances with predictable addresses using a factory pattern.

```go
package main

import (
	"fmt"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/contracts"
)

func main() {
	// Factory contract address
	factoryAddress, _ := new(felt.Felt).SetString("0x123456789abcdef")
	childClassHash, _ := new(felt.Felt).SetString("0x07e2e0ba00c247e6c2c7e38e8cadfcc59f828bb94c182e69bd8ea667bcbb65e7")

	fmt.Println("Factory Pattern: Precomputing Child Contract Addresses")
	fmt.Printf("Factory: %s\n", factoryAddress.String())
	fmt.Printf("Child Class: %s\n\n", childClassHash.String())

	// Create 5 child contracts with sequential salts
	for i := 0; i < 5; i++ {
		salt := new(felt.Felt).SetUint64(uint64(i))

		// Each child gets unique constructor parameters
		constructorCalldata := []*felt.Felt{
			new(felt.Felt).SetUint64(uint64(i * 100)), // child_id
		}

		childAddress := contracts.PrecomputeAddress(
			factoryAddress,
			salt,
			childClassHash,
			constructorCalldata,
		)

		fmt.Printf("Child %d:\n", i)
		fmt.Printf("  Salt: %s\n", salt.String())
		fmt.Printf("  Address: %s\n\n", childAddress.String())
	}
}
```

## Universal Deployer Contract (UDC)

Use the Universal Deployer Contract to deploy contracts with precomputed addresses.

```go
package main

import (
	"fmt"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/contracts"
)

func main() {
	// UDC address on Starknet
	udcAddress, _ := new(felt.Felt).SetString("0x041a78e741e5af2fec34b695679bc6891742439f7afb8484ecd7766661ad02bf")

	// Your contract class and deployment parameters
	classHash, _ := new(felt.Felt).SetString("0x07e2e0ba00c247e6c2c7e38e8cadfcc59f828bb94c182e69bd8ea667bcbb65e7")
	salt := new(felt.Felt).SetUint64(54321)
	constructorCalldata := []*felt.Felt{
		new(felt.Felt).SetUint64(1000),
	}

	// When using UDC, the deployer is the UDC address itself
	contractAddress := contracts.PrecomputeAddress(
		udcAddress, // Note: deployer is UDC, not your account
		salt,
		classHash,
		constructorCalldata,
	)

	fmt.Println("Universal Deployer Contract Pattern")
	fmt.Printf("UDC Address: %s\n", udcAddress.String())
	fmt.Printf("Class Hash: %s\n", classHash.String())
	fmt.Printf("Salt: %s\n", salt.String())
	fmt.Printf("Precomputed Address: %s\n", contractAddress.String())

	// Now deploy via UDC using account.DeployContractWithUDC()
	// The contract will be deployed at the precomputed address
}
```

## Account Abstraction Address Calculation

Precompute account contract addresses for account abstraction implementations.

```go
package main

import (
	"fmt"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/contracts"
)

func main() {
	// Account deployment parameters
	accountClassHash, _ := new(felt.Felt).SetString("0x01a736d6ed154502257f02b1ccdf4d9d1089f80811cd6acad48e6b6a9d1f2003")

	// User's public key
	publicKey, _ := new(felt.Felt).SetString("0x1234567890abcdef")

	// Salt for address uniqueness
	salt := new(felt.Felt).SetUint64(0)

	// Account constructor takes public key as calldata
	constructorCalldata := []*felt.Felt{publicKey}

	// Deployer is typically 0 for account contracts
	deployerAddress := new(felt.Felt).SetUint64(0)

	// Calculate account address
	accountAddress := contracts.PrecomputeAddress(
		deployerAddress,
		salt,
		accountClassHash,
		constructorCalldata,
	)

	fmt.Println("Account Abstraction Address Calculation")
	fmt.Printf("Account Class Hash: %s\n", accountClassHash.String())
	fmt.Printf("Public Key: %s\n", publicKey.String())
	fmt.Printf("Salt: %s\n", salt.String())
	fmt.Printf("Account Address: %s\n", accountAddress.String())
	fmt.Println("\nYou can now fund this address before deploying the account")
}
```

## Analyzing Contract ABIs

Parse and inspect contract ABIs to understand available functions and events.

```go
package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"

	"github.com/NethermindEth/starknet.go/contracts"
)

func main() {
	// Path to Sierra contract class (generated by Scarb build)
	sierraPath := "counter_contract/target/dev/counter_Counter.contract_class.json"

	// Load Sierra contract class
	content, err := os.ReadFile(sierraPath)
	if err != nil {
		log.Fatalf("Failed to read Sierra class: %v", err)
	}

	var contractClass contracts.ContractClass
	err = json.Unmarshal(content, &contractClass)
	if err != nil {
		log.Fatalf("Failed to unmarshal Sierra class: %v", err)
	}

	fmt.Printf("Contract Class Version: %s\n", contractClass.ContractClassVersion)
	fmt.Printf("Sierra Program Length: %d\n\n", len(contractClass.SierraProgram))

	// Parse ABI (it's a JSON string in Sierra classes)
	var abiEntries []interface{}
	err = json.Unmarshal([]byte(contractClass.ABI), &abiEntries)
	if err != nil {
		log.Printf("ABI parsing note: %v", err)
		return
	}

	// Count and display ABI entry types
	functionCount := 0
	eventCount := 0

	for _, entry := range abiEntries {
		entryMap, ok := entry.(map[string]interface{})
		if !ok {
			continue
		}

		entryType, ok := entryMap["type"].(string)
		if !ok {
			continue
		}

		switch entryType {
		case "function", "constructor", "l1_handler":
			functionCount++
			if name, ok := entryMap["name"].(string); ok {
				fmt.Printf("Function: %s\n", name)
			}
		case "event":
			eventCount++
			if name, ok := entryMap["name"].(string); ok {
				fmt.Printf("Event: %s\n", name)
			}
		}
	}

	fmt.Printf("\nABI Summary:\n")
	fmt.Printf("  Functions: %d\n", functionCount)
	fmt.Printf("  Events: %d\n", eventCount)
}
```

## Working with Entry Points

Access and inspect contract entry points from CASM classes.

```go
package main

import (
	"fmt"
	"log"

	"github.com/NethermindEth/starknet.go/contracts"
)

func main() {
	// Path to CASM class (generated by Scarb build)
	casmPath := "counter_contract/target/dev/counter_Counter.compiled_contract_class.json"

	// Load CASM class
	casmClass, err := contracts.UnmarshalCasmClass(casmPath)
	if err != nil {
		log.Fatalf("Failed to load CASM class: %v", err)
	}

	// Inspect constructor entry points
	fmt.Println("Constructor Entry Points:")
	for i, ep := range casmClass.EntryPointsByType.Constructor {
		fmt.Printf("  [%d] Selector: %s\n", i, ep.Selector.String())
		fmt.Printf("      Offset: %d\n", ep.Offset)
		fmt.Printf("      Builtins: %v\n", ep.Builtins)
	}

	// Inspect external entry points
	fmt.Println("\nExternal Entry Points:")
	for i, ep := range casmClass.EntryPointsByType.External {
		fmt.Printf("  [%d] Selector: %s\n", i, ep.Selector.String())
		fmt.Printf("      Offset: %d\n", ep.Offset)
		fmt.Printf("      Builtins: %v\n", ep.Builtins)
	}

	// Inspect L1 handler entry points
	fmt.Println("\nL1 Handler Entry Points:")
	for i, ep := range casmClass.EntryPointsByType.L1Handler {
		fmt.Printf("  [%d] Selector: %s\n", i, ep.Selector.String())
		fmt.Printf("      Offset: %d\n", ep.Offset)
		fmt.Printf("      Builtins: %v\n", ep.Builtins)
	}

	// Bytecode statistics
	fmt.Printf("\nBytecode Statistics:\n")
	fmt.Printf("  Total Instructions: %d\n", len(casmClass.ByteCode))
	fmt.Printf("  Hints: %d\n", len(casmClass.Hints))
}
```

## Deterministic Deployment Verification

Verify that the same deployment parameters always produce the same address.

```go
package main

import (
	"fmt"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/contracts"
)

func main() {
	// Fixed parameters
	deployerAddress, _ := new(felt.Felt).SetString("0x1234")
	salt, _ := new(felt.Felt).SetString("0x5678")
	classHash, _ := new(felt.Felt).SetString("0x07e2e0ba00c247e6c2c7e38e8cadfcc59f828bb94c182e69bd8ea667bcbb65e7")
	constructorCalldata := []*felt.Felt{
		new(felt.Felt).SetUint64(100),
	}

	fmt.Println("Deterministic Deployment Verification")
	fmt.Println("Computing address 5 times with same parameters...\n")

	// Compute address multiple times
	addresses := make([]string, 5)
	for i := 0; i < 5; i++ {
		addr := contracts.PrecomputeAddress(
			deployerAddress,
			salt,
			classHash,
			constructorCalldata,
		)
		addresses[i] = addr.String()
		fmt.Printf("Attempt %d: %s\n", i+1, addresses[i])
	}

	// Verify all addresses are identical
	allSame := true
	for i := 1; i < len(addresses); i++ {
		if addresses[i] != addresses[0] {
			allSame = false
			break
		}
	}

	if allSame {
		fmt.Println("\nAll addresses are identical - deployment is deterministic")
	} else {
		fmt.Println("\nAddresses differ - deployment is NOT deterministic")
	}
}
```

## Multiple Instance Deployment

Deploy multiple instances of the same contract class using different salts.

```go
package main

import (
	"fmt"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/contracts"
)

func main() {
	deployerAddress, _ := new(felt.Felt).SetString("0x1234")
	classHash, _ := new(felt.Felt).SetString("0x07e2e0ba00c247e6c2c7e38e8cadfcc59f828bb94c182e69bd8ea667bcbb65e7")

	fmt.Println("Deploying Multiple Contract Instances")
	fmt.Printf("Deployer: %s\n", deployerAddress.String())
	fmt.Printf("Class Hash: %s\n\n", classHash.String())

	// Deploy 3 token contracts with different initial supplies
	supplies := []uint64{1000000, 5000000, 10000000}

	for i, supply := range supplies {
		// Unique salt for each instance
		salt := new(felt.Felt).SetUint64(uint64(i + 1))

		// Different constructor parameters
		constructorCalldata := []*felt.Felt{
			new(felt.Felt).SetUint64(supply), // initial_supply
		}

		contractAddress := contracts.PrecomputeAddress(
			deployerAddress,
			salt,
			classHash,
			constructorCalldata,
		)

		fmt.Printf("Token %d:\n", i+1)
		fmt.Printf("  Initial Supply: %d\n", supply)
		fmt.Printf("  Salt: %s\n", salt.String())
		fmt.Printf("  Address: %s\n\n", contractAddress.String())
	}
}
```
