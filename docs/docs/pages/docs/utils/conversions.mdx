# Conversion Functions

Utility functions for converting between different data types commonly used in Starknet development.

## Felt Conversions

### HexToFelt

Converts a hexadecimal string to a Felt object.

```go
func HexToFelt(hex string) (*felt.Felt, error)
```

**Parameters:**
- `hex` - The input hexadecimal string to be converted

**Returns:**
- `*felt.Felt` - A pointer to the converted Felt object
- `error` - Error if conversion fails

**Usage Example:**

```go
package main

import (
	"fmt"
	"log"

	"github.com/NethermindEth/starknet.go/utils"
)

func main() {
	// Convert hex string to felt
	address, err := utils.HexToFelt("0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7")
	if err != nil {
		log.Fatal("Conversion failed:", err)
	}

	fmt.Printf("Felt: %s\n", address)
}
```

### HexArrToFelt

Converts an array of hexadecimal strings to an array of Felt objects.

```go
func HexArrToFelt(hexArr []string) ([]*felt.Felt, error)
```

**Parameters:**
- `hexArr` - An array of strings representing hexadecimal values

**Returns:**
- `[]*felt.Felt` - An array of Felt objects
- `error` - Error if any conversion fails

**Usage Example:**

```go
hexStrings := []string{
	"0x1",
	"0x2",
	"0x3",
}

felts, err := utils.HexArrToFelt(hexStrings)
if err != nil {
	log.Fatal("Conversion failed:", err)
}

fmt.Printf("Converted %d felts\n", len(felts))
```

### FeltArrToStringArr

Converts an array of Felt objects to an array of string objects.

```go
func FeltArrToStringArr(f []*felt.Felt) []string
```

**Parameters:**
- `f` - The array of Felt objects to convert

**Returns:**
- `[]string` - The array of string objects

**Usage Example:**

```go
felts := []*felt.Felt{
	new(felt.Felt).SetUint64(1),
	new(felt.Felt).SetUint64(2),
	new(felt.Felt).SetUint64(3),
}

strings := utils.FeltArrToStringArr(felts)
fmt.Printf("Strings: %v\n", strings)
```

## Big.Int Conversions

### BigIntToFelt

Converts a big integer to a Felt.

```go
func BigIntToFelt(bigNum *big.Int) *felt.Felt
```

**Parameters:**
- `bigNum` - The big integer to convert

**Returns:**
- `*felt.Felt` - The converted Felt value

**Usage Example:**

```go
import "math/big"

bigNum := big.NewInt(12345)
feltNum := utils.BigIntToFelt(bigNum)
fmt.Printf("Felt: %s\n", feltNum)
```

### FeltToBigInt

Converts a Felt value to a big.Int.

```go
func FeltToBigInt(f *felt.Felt) *big.Int
```

**Parameters:**
- `f` - The Felt value to convert

**Returns:**
- `*big.Int` - The converted value

**Usage Example:**

```go
felt := new(felt.Felt).SetUint64(12345)
bigNum := utils.FeltToBigInt(felt)
fmt.Printf("Big.Int: %s\n", bigNum.String())
```

### BigIntArrToFeltArr

Converts an array of big.Int objects to an array of Felt objects.

```go
func BigIntArrToFeltArr(bigArr []*big.Int) []*felt.Felt
```

**Parameters:**
- `bigArr` - The array of big.Int objects to convert

**Returns:**
- `[]*felt.Felt` - The array of Felt objects

**Usage Example:**

```go
bigInts := []*big.Int{
	big.NewInt(1),
	big.NewInt(2),
	big.NewInt(3),
}

felts := utils.BigIntArrToFeltArr(bigInts)
fmt.Printf("Converted %d felts\n", len(felts))
```

### FeltArrToBigIntArr

Converts an array of Felt objects to an array of big.Int objects.

```go
func FeltArrToBigIntArr(f []*felt.Felt) []*big.Int
```

**Parameters:**
- `f` - The array of Felt objects to convert

**Returns:**
- `[]*big.Int` - The array of big.Int objects

**Usage Example:**

```go
felts := []*felt.Felt{
	new(felt.Felt).SetUint64(1),
	new(felt.Felt).SetUint64(2),
}

bigInts := utils.FeltArrToBigIntArr(felts)
fmt.Printf("Converted %d big.Ints\n", len(bigInts))
```

## Hex and Byte Conversions

### HexToBN

Converts a hexadecimal string to a big.Int. Automatically trims the "0x" prefix if it exists.

```go
func HexToBN(hexString string) *big.Int
```

**Parameters:**
- `hexString` - The hexadecimal string to be converted

**Returns:**
- `*big.Int` - The converted value

**Usage Example:**

```go
bigNum := utils.HexToBN("0x1234")
fmt.Printf("Big.Int: %s\n", bigNum.String())
```

### BigToHex

Converts a big integer to its hexadecimal representation.

```go
func BigToHex(in *big.Int) string
```

**Parameters:**
- `in` - The big integer to be converted

**Returns:**
- `string` - The hexadecimal representation

**Usage Example:**

```go
bigNum := big.NewInt(4660)
hex := utils.BigToHex(bigNum)
fmt.Printf("Hex: %s\n", hex) // Output: 0x1234
```

### HexToBytes

Converts a hexadecimal string to a byte slice. Automatically trims the "0x" prefix if it exists.

```go
func HexToBytes(hexString string) ([]byte, error)
```

**Parameters:**
- `hexString` - The hexadecimal string to be converted

**Returns:**
- `[]byte` - The converted byte slice
- `error` - An error if conversion fails

**Usage Example:**

```go
bytes, err := utils.HexToBytes("0x48656c6c6f")
if err != nil {
	log.Fatal("Conversion failed:", err)
}
fmt.Printf("Bytes: %v\n", bytes)
```

### BytesToBig

Converts a byte slice to a big.Int.

```go
func BytesToBig(bytes []byte) *big.Int
```

**Parameters:**
- `bytes` - The byte slice to be converted

**Returns:**
- `*big.Int` - The converted value

**Usage Example:**

```go
bytes := []byte{0x12, 0x34}
bigNum := utils.BytesToBig(bytes)
fmt.Printf("Big.Int: %s\n", bigNum.String())
```

## String Conversions

### StringToByteArrFelt

Converts a string to an array of Felt objects following the Cairo ByteArray format.

The returned array follows the Cairo ByteArray serialization format:
`[number of 31-byte felts, 31-byte felts..., pending word (max 30 bytes), pending word byte size]`

For more details, see the [Starknet documentation on ByteArray serialization](https://docs.starknet.io/architecture-and-concepts/smart-contracts/serialization-of-cairo-types/#serialization_of_byte_arrays).

```go
func StringToByteArrFelt(s string) ([]*felt.Felt, error)
```

**Parameters:**
- `s` - String/bytearray to convert

**Returns:**
- `[]*felt.Felt` - The array of Felt objects
- `error` - An error if any

**Usage Example:**

```go
str := "Hello, Starknet!"
felts, err := utils.StringToByteArrFelt(str)
if err != nil {
	log.Fatal("Conversion failed:", err)
}
fmt.Printf("Converted to %d felts\n", len(felts))
```

### ByteArrFeltToString

Converts an array of Felts to a string following the Cairo ByteArray format.

The input array should follow the Cairo ByteArray serialization format:
`[number of 31-byte felts, 31-byte felts..., pending word (max 30 bytes), pending word byte size]`

For more details, see the [Starknet documentation on ByteArray serialization](https://docs.starknet.io/architecture-and-concepts/smart-contracts/serialization-of-cairo-types/#serialization_of_byte_arrays).

```go
func ByteArrFeltToString(arr []*felt.Felt) (string, error)
```

**Parameters:**
- `arr` - The array of Felt objects

**Returns:**
- `string` - The converted string
- `error` - An error if any

**Usage Example:**

```go
// Assuming 'felts' is a ByteArray format felt array
str, err := utils.ByteArrFeltToString(felts)
if err != nil {
	log.Fatal("Conversion failed:", err)
}
fmt.Printf("String: %s\n", str)
```

### HexToShortStr

Converts a hexadecimal string to a short string (Cairo short string representation).

```go
func HexToShortStr(hexStr string) string
```

**Parameters:**
- `hexStr` - The hexadecimal string to convert

**Returns:**
- `string` - A short string

**Usage Example:**

```go
// 0x455448 represents "ETH" in hex
shortStr := utils.HexToShortStr("0x455448")
fmt.Printf("Short string: %s\n", shortStr) // Output: ETH
```

## Numeric Conversions

### Uint64ToFelt

Generates a new Felt from a given uint64 number.

```go
func Uint64ToFelt(num uint64) *felt.Felt
```

**Parameters:**
- `num` - The uint64 number to convert to a Felt

**Returns:**
- `*felt.Felt` - A Felt representation of the number

**Usage Example:**

```go
felt := utils.Uint64ToFelt(12345)
fmt.Printf("Felt: %s\n", felt)
```

## U256 Conversions

### HexToU256Felt

Converts a hexadecimal string to a Cairo u256 representation.

The Cairo u256 is represented as two Felt values:
- The first Felt contains the 128 least significant bits (low part)
- The second Felt contains the 128 most significant bits (high part)

```go
func HexToU256Felt(hexStr string) ([]*felt.Felt, error)
```

**Parameters:**
- `hexStr` - The hexadecimal string to convert to a Cairo u256

**Returns:**
- `[]*felt.Felt` - A slice containing two Felt values [low, high]
- `error` - Error if conversion fails

**Usage Example:**

```go
// Convert a large hex value to u256
u256, err := utils.HexToU256Felt("0x123456789abcdef0123456789abcdef0")
if err != nil {
	log.Fatal("Conversion failed:", err)
}
fmt.Printf("U256 low: %s, high: %s\n", u256[0], u256[1])
```

### U256FeltToHex

Converts a Cairo u256 representation (two Felt values) back to a hexadecimal string.

The Cairo u256 is represented as two Felt values:
- The first Felt contains the 128 least significant bits (low part)
- The second Felt contains the 128 most significant bits (high part)

```go
func U256FeltToHex(u256 []*felt.Felt) (string, error)
```

**Parameters:**
- `u256` - A slice containing two Felt values [low, high]

**Returns:**
- `string` - The hexadecimal representation of the combined value
- `error` - Error if conversion fails

**Usage Example:**

```go
// Convert u256 back to hex
low := new(felt.Felt).SetUint64(0x123456789abcdef0)
high := new(felt.Felt).SetUint64(0x123456789abcdef0)
u256 := []*felt.Felt{low, high}

hex, err := utils.U256FeltToHex(u256)
if err != nil {
	log.Fatal("Conversion failed:", err)
}
fmt.Printf("Hex: %s\n", hex)
```

## Related

- [Cryptographic Utilities](./cryptographic.mdx) - Cryptographic and hashing functions
- [Unit Conversions](./unit-conversions.mdx) - Currency and unit conversions
- [Types](./types.mdx) - Type definitions
