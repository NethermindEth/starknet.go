# TransactionHashInvokeV3

Calculates the transaction hash for an Invoke V3 transaction using the Poseidon hash algorithm. V3 introduces resource bounds, data availability modes, and paymaster support for more efficient and flexible fee payment.

## Function Signature

```go
func TransactionHashInvokeV3(txn *rpc.InvokeTxnV3, chainID *felt.Felt) (*felt.Felt, error)
```

**Source:** [hash.go:L426-L477](https://github.com/NethermindEth/starknet.go/blob/main/hash/hash.go#L426-L477)

## Parameters

- `txn` (*rpc.InvokeTxnV3): The Invoke V3 transaction containing Version, SenderAddress, Calldata, Nonce, ResourceBounds, Tip, PayMasterData, AccountDeploymentData, FeeMode, and NonceDataMode
- `chainID` (*felt.Felt): The Starknet chain ID

## Returns

- `*felt.Felt`: The calculated transaction hash
- `error`: Error if required parameters are missing

## Usage Example

```go
package main

import (
	"context"
	"fmt"
	"log"
	"os"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/hash"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/joho/godotenv"
)

func main() {
	if err := godotenv.Load(); err != nil {
		log.Printf("Warning: .env file not found: %v", err)
	}

	chainID, _ := new(felt.Felt).SetString("0x534e5f5345504f4c4941")
	senderAddress, _ := new(felt.Felt).SetString("0x04718f5a0fc34cc1af16a1cdee98ffb20c31f5cd61d6ab07201858f4287c938d")
	nonce := new(felt.Felt).SetUint64(5)

	ethContract, _ := new(felt.Felt).SetString("0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7")
	transferSelector, _ := new(felt.Felt).SetString("0x83afd3f4caedc6eebf44246fe54e38c95e3179a5ec9ea81740eca5b482d12e")

	calldata := []*felt.Felt{
		new(felt.Felt).SetUint64(1),
		ethContract,
		transferSelector,
		new(felt.Felt).SetUint64(2),
		new(felt.Felt).SetUint64(1),
		new(felt.Felt).SetUint64(2),
	}

	resourceBounds := &rpc.ResourceBoundsMapping{
		L1Gas: rpc.ResourceBounds{
			MaxAmount:       "0x5000",
			MaxPricePerUnit: "0x33a937098d80",
		},
		L1DataGas: rpc.ResourceBounds{
			MaxAmount:       "0x5000",
			MaxPricePerUnit: "0x33a937098d80",
		},
		L2Gas: rpc.ResourceBounds{
			MaxAmount:       "0x5000",
			MaxPricePerUnit: "0x10c388d00",
		},
	}

	txn := &rpc.InvokeTxnV3{
		Type:                  rpc.TransactionTypeInvoke,
		Version:               rpc.TransactionV3,
		SenderAddress:         senderAddress,
		Nonce:                 nonce,
		Calldata:              calldata,
		Signature:             []*felt.Felt{},
		ResourceBounds:        resourceBounds,
		Tip:                   "0x0",
		PayMasterData:         []*felt.Felt{},
		AccountDeploymentData: []*felt.Felt{},
		NonceDataMode:         rpc.DAModeL1,
		FeeMode:               rpc.DAModeL1,
	}

	txHash, err := hash.TransactionHashInvokeV3(txn, chainID)
	if err != nil {
		log.Fatalf("Failed to calculate transaction hash: %v", err)
	}

	fmt.Printf("Transaction Hash: %s\n", txHash.String())

	if rpcURL := os.Getenv("STARKNET_RPC_URL"); rpcURL != "" {
		verifyTransaction(txHash, rpcURL)
	}
}

func verifyTransaction(txHash *felt.Felt, rpcURL string) {
	client, err := rpc.NewProvider(context.Background(), rpcURL)
	if err != nil {
		log.Printf("Warning: Could not connect to RPC: %v", err)
		return
	}

	ctx := context.Background()
	tx, err := client.TransactionByHash(ctx, txHash)

	if err == nil {
		fmt.Printf("\nVerification: FOUND on-chain\n")
		fmt.Printf("Type: %T\n", tx)
	} else {
		fmt.Printf("\nVerification: NOT FOUND\n")
	}
}
```

## Common Use Cases

This function is commonly used for:

- Computing transaction hashes for modern Starknet invoke transactions when signing transactions in wallet applications or smart contract interactions. See [Transaction Hash - Invoke V3 example](/docs/hash/examples#transaction-hash---invoke-v3).
- Verifying transaction hashes for V3 transactions when building blockchain explorers or analytics platforms that process current Starknet network activity.
- Implementing transaction broadcasting systems that need to calculate and validate transaction hashes before submitting them to the network.
- Creating transaction monitoring tools that track and verify invoke transactions with resource bounds and paymaster support for fee abstraction.
- Building testing frameworks that simulate V3 transaction scenarios to ensure proper handling of resource bounds and data availability modes.

