# TransactionHashInvokeV1

import { Callout } from 'vocs/components'

<Callout type="info">
  **Note**: V1 transactions are deprecated. For new applications, use [TransactionHashInvokeV3](./transaction-hash-invoke-v3) for V3 transactions.
</Callout>

Calculates the transaction hash for an Invoke V1 transaction using the deprecated Pedersen-based hash calculation. V1 introduced nonce support for replay protection.

## Function Signature

```go
func TransactionHashInvokeV1(txn *rpc.InvokeTxnV1, chainID *felt.Felt) (*felt.Felt, error)
```

**Source:** [hash.go:L391-L425](https://github.com/NethermindEth/starknet.go/blob/main/hash/hash.go#L391-L425)

## Parameters

- `txn` (*rpc.InvokeTxnV1): The Invoke V1 transaction containing Version, SenderAddress, Calldata, MaxFee, and Nonce
- `chainID` (*felt.Felt): The Starknet chain ID

## Returns

- `*felt.Felt`: The calculated transaction hash
- `error`: Error if required parameters are missing

## Usage Example

```go
package main

import (
	"context"
	"fmt"
	"log"
	"os"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/hash"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/joho/godotenv"
)

func main() {
	if err := godotenv.Load(); err != nil {
		log.Printf("Warning: .env file not found: %v", err)
	}

	chainID, _ := new(felt.Felt).SetString("0x534e5f5345504f4c4941")
	senderAddress, _ := new(felt.Felt).SetString("0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef")
	maxFee := new(felt.Felt).SetUint64(2000000000000000)
	nonce := new(felt.Felt).SetUint64(5)

	ethContract, _ := new(felt.Felt).SetString("0x049d36570d4e46f48e99674bd3fcc84644ddd6b96f7c741b1562b82f9e004dc7")
	transferSelector, _ := new(felt.Felt).SetString("0x83afd3f4caedc6eebf44246fe54e38c95e3179a5ec9ea81740eca5b482d12e")

	calldata := []*felt.Felt{
		new(felt.Felt).SetUint64(1),
		ethContract,
		transferSelector,
		new(felt.Felt).SetUint64(2),
		new(felt.Felt).SetUint64(1),
		new(felt.Felt).SetUint64(2),
	}

	txn := &rpc.InvokeTxnV1{
		Type:          rpc.TransactionTypeInvoke,
		Version:       rpc.TransactionV1,
		SenderAddress: senderAddress,
		Nonce:         nonce,
		MaxFee:        maxFee,
		Calldata:      calldata,
		Signature:     []*felt.Felt{},
	}

	txHash, err := hash.TransactionHashInvokeV1(txn, chainID)
	if err != nil {
		log.Fatalf("Failed to calculate transaction hash: %v", err)
	}

	fmt.Printf("Transaction Hash: %s\n", txHash.String())

	if rpcURL := os.Getenv("STARKNET_RPC_URL"); rpcURL != "" {
		verifyTransaction(txHash, rpcURL)
	}
}

func verifyTransaction(txHash *felt.Felt, rpcURL string) {
	client, err := rpc.NewProvider(context.Background(), rpcURL)
	if err != nil {
		log.Printf("Warning: Could not connect to RPC: %v", err)
		return
	}

	ctx := context.Background()
	tx, err := client.TransactionByHash(ctx, txHash)

	if err == nil {
		fmt.Printf("\nVerification: FOUND on-chain\n")
		fmt.Printf("Type: %T\n", tx)
	} else {
		fmt.Printf("\nVerification: NOT FOUND\n")
	}
}
```

## Common Use Cases

This function is commonly used for:

- Processing historical Starknet V1 transactions from archive nodes when building blockchain explorers or analytics platforms that need to verify transaction hashes.
- Implementing transaction replay detection systems that verify nonce values by recalculating and comparing transaction hashes against recorded values.
- Building migration tools that help transition from V1 to V3 transaction formats by analyzing historical transaction patterns and calculating legacy hashes.
- Creating audit and compliance tools that verify the integrity of historical transaction data by independently computing and validating transaction hashes.
- Developing testing frameworks that simulate historical transaction scenarios to ensure backward compatibility when implementing new Starknet features.

