# Transaction Hash Functions

Transaction hash functions calculate unique identifiers for Starknet transactions. Each transaction type and version has its own hash calculation method that follows the Starknet specification.

## Overview

Transaction hashes serve as unique identifiers for transactions on Starknet. The hash calculation varies based on:

- Transaction type (Invoke, Declare, Deploy Account)
- Transaction version (V0, V1, V2, V3)
- Network chain ID

## Invoke Transaction Hashes

### TransactionHashInvokeV0

Calculates the transaction hash for a deprecated Invoke V0 transaction.

#### Signature

```go
func TransactionHashInvokeV0(
	txn *rpc.InvokeTxnV0,
	chainID *felt.Felt,
) (*felt.Felt, error)
```

#### Parameters

- `txn` - The Invoke V0 transaction containing:
  - `Version` - Transaction version string
  - `ContractAddress` - Address of the contract being invoked
  - `EntryPointSelector` - Selector of the function to call
  - `Calldata` - Array of felt values as function parameters
  - `MaxFee` - Maximum fee willing to pay
- `chainID` - The Starknet chain ID

#### Returns

- `*felt.Felt` - The calculated transaction hash
- `error` - Error if required parameters are missing

#### Usage Example

```go
package main

import (
	"fmt"
	"log"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/hash"
	"github.com/NethermindEth/starknet.go/rpc"
)

func main() {
	// Create Invoke V0 transaction
	txn := &rpc.InvokeTxnV0{
		Version:            "0x0",
		ContractAddress:    new(felt.Felt).SetUint64(12345),
		EntryPointSelector: new(felt.Felt).SetUint64(67890),
		Calldata: []*felt.Felt{
			new(felt.Felt).SetUint64(1),
			new(felt.Felt).SetUint64(2),
		},
		MaxFee: new(felt.Felt).SetUint64(1000000),
	}

	// Sepolia testnet chain ID
	chainID := new(felt.Felt).SetBytes([]byte("SN_SEPOLIA"))

	// Calculate hash
	txHash, err := hash.TransactionHashInvokeV0(txn, chainID)
	if err != nil {
		log.Fatal("Failed to calculate hash:", err)
	}

	fmt.Printf("Transaction Hash: %s\n", txHash.String())
}
```

#### Specification

Follows the [V0 hash calculation specification](https://docs.starknet.io/architecture-and-concepts/network-architecture/transactions/#v0_deprecated_hash_calculation).

---

### TransactionHashInvokeV1

Calculates the transaction hash for an Invoke V1 transaction.

#### Signature

```go
func TransactionHashInvokeV1(
	txn *rpc.InvokeTxnV1,
	chainID *felt.Felt,
) (*felt.Felt, error)
```

#### Parameters

- `txn` - The Invoke V1 transaction containing:
  - `Version` - Transaction version string (typically "0x1")
  - `SenderAddress` - Address of the account sending the transaction
  - `Calldata` - Array of felt values as function parameters
  - `MaxFee` - Maximum fee willing to pay
  - `Nonce` - Account nonce
- `chainID` - The Starknet chain ID

#### Returns

- `*felt.Felt` - The calculated transaction hash
- `error` - Error if required parameters are missing

#### Usage Example

```go
package main

import (
	"fmt"
	"log"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/hash"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/NethermindEth/starknet.go/utils"
)

func main() {
	// Parse sender address
	senderAddr, _ := utils.HexToFelt("0x1234567890abcdef")

	// Create Invoke V1 transaction
	txn := &rpc.InvokeTxnV1{
		Version:       "0x1",
		SenderAddress: senderAddr,
		Calldata: []*felt.Felt{
			new(felt.Felt).SetUint64(1),
			new(felt.Felt).SetUint64(2),
		},
		MaxFee: new(felt.Felt).SetUint64(1000000),
		Nonce:  new(felt.Felt).SetUint64(1),
	}

	// Sepolia chain ID
	chainID := new(felt.Felt).SetBytes([]byte("SN_SEPOLIA"))

	// Calculate hash
	txHash, err := hash.TransactionHashInvokeV1(txn, chainID)
	if err != nil {
		log.Fatal("Failed to calculate hash:", err)
	}

	fmt.Printf("Transaction Hash: %s\n", txHash.String())
}
```

#### Specification

Follows the [V1 hash calculation specification](https://docs.starknet.io/architecture-and-concepts/network-architecture/transactions/#v1_deprecated_hash_calculation).

---

### TransactionHashInvokeV3

Calculates the transaction hash for an Invoke V3 transaction with resource bounds.

#### Signature

```go
func TransactionHashInvokeV3(
	txn *rpc.InvokeTxnV3,
	chainID *felt.Felt,
) (*felt.Felt, error)
```

#### Parameters

- `txn` - The Invoke V3 transaction containing:
  - `Version` - Transaction version string (typically "0x3")
  - `SenderAddress` - Address of the account sending the transaction
  - `Calldata` - Array of felt values as function parameters
  - `Nonce` - Account nonce
  - `ResourceBounds` - Resource bounds for L1 gas, L2 gas, and L1 data gas
  - `Tip` - Additional fee tip
  - `PayMasterData` - Optional paymaster data
  - `AccountDeploymentData` - Optional account deployment data
  - `FeeMode` - Fee data availability mode
  - `NonceDataMode` - Nonce data availability mode
- `chainID` - The Starknet chain ID

#### Returns

- `*felt.Felt` - The calculated transaction hash
- `error` - Error if required parameters are missing

#### Usage Example

```go
package main

import (
	"fmt"
	"log"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/hash"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/NethermindEth/starknet.go/utils"
)

func main() {
	// Parse sender address
	senderAddr, _ := utils.HexToFelt("0x1234567890abcdef")

	// Create Invoke V3 transaction
	txn := &rpc.InvokeTxnV3{
		Version:       "0x3",
		SenderAddress: senderAddr,
		Calldata: []*felt.Felt{
			new(felt.Felt).SetUint64(1),
		},
		Nonce: new(felt.Felt).SetUint64(1),
		ResourceBounds: &rpc.ResourceBoundsMapping{
			L1Gas: rpc.ResourceBounds{
				MaxAmount:       new(felt.Felt).SetUint64(50000),
				MaxPricePerUnit: new(felt.Felt).SetUint64(100),
			},
			L2Gas: rpc.ResourceBounds{
				MaxAmount:       new(felt.Felt).SetUint64(0),
				MaxPricePerUnit: new(felt.Felt).SetUint64(0),
			},
			L1DataGas: rpc.ResourceBounds{
				MaxAmount:       new(felt.Felt).SetUint64(0),
				MaxPricePerUnit: new(felt.Felt).SetUint64(0),
			},
		},
		Tip:                   new(felt.Felt).SetUint64(0),
		PayMasterData:         []*felt.Felt{},
		AccountDeploymentData: []*felt.Felt{},
		FeeMode:               rpc.DAModeL1,
		NonceDataMode:         rpc.DAModeL1,
	}

	// Sepolia chain ID
	chainID := new(felt.Felt).SetBytes([]byte("SN_SEPOLIA"))

	// Calculate hash
	txHash, err := hash.TransactionHashInvokeV3(txn, chainID)
	if err != nil {
		log.Fatal("Failed to calculate hash:", err)
	}

	fmt.Printf("Transaction Hash: %s\n", txHash.String())
}
```

#### Specification

Follows the [V3 hash calculation specification](https://docs.starknet.io/architecture-and-concepts/network-architecture/transactions/#v3_hash_calculation) and [SNIP-8](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-8.md#protocol-changes).

---

## Declare Transaction Hashes

### TransactionHashDeclareV1

Calculates the transaction hash for a Declare V1 transaction.

#### Signature

```go
func TransactionHashDeclareV1(
	txn *rpc.DeclareTxnV1,
	chainID *felt.Felt,
) (*felt.Felt, error)
```

#### Parameters

- `txn` - The Declare V1 transaction containing:
  - `Version` - Transaction version string
  - `SenderAddress` - Address of the account declaring the class
  - `ClassHash` - Hash of the contract class being declared
  - `MaxFee` - Maximum fee willing to pay
  - `Nonce` - Account nonce
- `chainID` - The Starknet chain ID

#### Returns

- `*felt.Felt` - The calculated transaction hash
- `error` - Error if required parameters are missing

#### Usage Example

```go
package main

import (
	"fmt"
	"log"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/hash"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/NethermindEth/starknet.go/utils"
)

func main() {
	senderAddr, _ := utils.HexToFelt("0x1234567890abcdef")
	classHash, _ := utils.HexToFelt("0xabcdef1234567890")

	txn := &rpc.DeclareTxnV1{
		Version:       "0x1",
		SenderAddress: senderAddr,
		ClassHash:     classHash,
		MaxFee:        new(felt.Felt).SetUint64(1000000),
		Nonce:         new(felt.Felt).SetUint64(1),
	}

	chainID := new(felt.Felt).SetBytes([]byte("SN_SEPOLIA"))

	txHash, err := hash.TransactionHashDeclareV1(txn, chainID)
	if err != nil {
		log.Fatal("Failed to calculate hash:", err)
	}

	fmt.Printf("Transaction Hash: %s\n", txHash.String())
}
```

#### Specification

Follows the [V1 Declare hash calculation specification](https://docs.starknet.io/architecture-and-concepts/network-architecture/transactions/#v1_deprecated_hash_calculation_2).

---

### TransactionHashDeclareV2

Calculates the transaction hash for a Declare V2 transaction.

#### Signature

```go
func TransactionHashDeclareV2(
	txn *rpc.DeclareTxnV2,
	chainID *felt.Felt,
) (*felt.Felt, error)
```

#### Parameters

- `txn` - The Declare V2 transaction containing:
  - `Version` - Transaction version string
  - `SenderAddress` - Address of the account declaring the class
  - `ClassHash` - Hash of the Sierra contract class
  - `CompiledClassHash` - Hash of the compiled (CASM) class
  - `MaxFee` - Maximum fee willing to pay
  - `Nonce` - Account nonce
- `chainID` - The Starknet chain ID

#### Returns

- `*felt.Felt` - The calculated transaction hash
- `error` - Error if required parameters are missing

#### Usage Example

```go
package main

import (
	"fmt"
	"log"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/hash"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/NethermindEth/starknet.go/utils"
)

func main() {
	senderAddr, _ := utils.HexToFelt("0x1234567890abcdef")
	classHash, _ := utils.HexToFelt("0xabcdef1234567890")
	compiledHash, _ := utils.HexToFelt("0x9876543210fedcba")

	txn := &rpc.DeclareTxnV2{
		Version:           "0x2",
		SenderAddress:     senderAddr,
		ClassHash:         classHash,
		CompiledClassHash: compiledHash,
		MaxFee:            new(felt.Felt).SetUint64(1000000),
		Nonce:             new(felt.Felt).SetUint64(1),
	}

	chainID := new(felt.Felt).SetBytes([]byte("SN_SEPOLIA"))

	txHash, err := hash.TransactionHashDeclareV2(txn, chainID)
	if err != nil {
		log.Fatal("Failed to calculate hash:", err)
	}

	fmt.Printf("Transaction Hash: %s\n", txHash.String())
}
```

#### Specification

Follows the [V2 Declare hash calculation specification](https://docs.starknet.io/architecture-and-concepts/network-architecture/transactions/#v2_deprecated_hash_calculation).

---

### TransactionHashDeclareV3

Calculates the transaction hash for a Declare V3 transaction with resource bounds.

#### Signature

```go
func TransactionHashDeclareV3(
	txn *rpc.DeclareTxnV3,
	chainID *felt.Felt,
) (*felt.Felt, error)
```

#### Parameters

- `txn` - The Declare V3 transaction containing:
  - `Version` - Transaction version string
  - `SenderAddress` - Address of the account declaring the class
  - `ClassHash` - Hash of the Sierra contract class
  - `CompiledClassHash` - Hash of the compiled (CASM) class
  - `Nonce` - Account nonce
  - `ResourceBounds` - Resource bounds for L1 gas, L2 gas, and L1 data gas
  - `Tip` - Additional fee tip
  - `PayMasterData` - Optional paymaster data
  - `AccountDeploymentData` - Optional account deployment data
  - `FeeMode` - Fee data availability mode
  - `NonceDataMode` - Nonce data availability mode
- `chainID` - The Starknet chain ID

#### Returns

- `*felt.Felt` - The calculated transaction hash
- `error` - Error if required parameters are missing

#### Usage Example

```go
package main

import (
	"fmt"
	"log"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/hash"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/NethermindEth/starknet.go/utils"
)

func main() {
	senderAddr, _ := utils.HexToFelt("0x1234567890abcdef")
	classHash, _ := utils.HexToFelt("0xabcdef1234567890")
	compiledHash, _ := utils.HexToFelt("0x9876543210fedcba")

	txn := &rpc.DeclareTxnV3{
		Version:           "0x3",
		SenderAddress:     senderAddr,
		ClassHash:         classHash,
		CompiledClassHash: compiledHash,
		Nonce:             new(felt.Felt).SetUint64(1),
		ResourceBounds: &rpc.ResourceBoundsMapping{
			L1Gas: rpc.ResourceBounds{
				MaxAmount:       new(felt.Felt).SetUint64(50000),
				MaxPricePerUnit: new(felt.Felt).SetUint64(100),
			},
			L2Gas: rpc.ResourceBounds{
				MaxAmount:       new(felt.Felt).SetUint64(0),
				MaxPricePerUnit: new(felt.Felt).SetUint64(0),
			},
			L1DataGas: rpc.ResourceBounds{
				MaxAmount:       new(felt.Felt).SetUint64(0),
				MaxPricePerUnit: new(felt.Felt).SetUint64(0),
			},
		},
		Tip:                   new(felt.Felt).SetUint64(0),
		PayMasterData:         []*felt.Felt{},
		AccountDeploymentData: []*felt.Felt{},
		FeeMode:               rpc.DAModeL1,
		NonceDataMode:         rpc.DAModeL1,
	}

	chainID := new(felt.Felt).SetBytes([]byte("SN_SEPOLIA"))

	txHash, err := hash.TransactionHashDeclareV3(txn, chainID)
	if err != nil {
		log.Fatal("Failed to calculate hash:", err)
	}

	fmt.Printf("Transaction Hash: %s\n", txHash.String())
}
```

#### Specification

Follows the [V3 Declare hash calculation specification](https://docs.starknet.io/architecture-and-concepts/network-architecture/transactions/#v3_hash_calculation_2) and [SNIP-8](https://github.com/starknet-io/SNIPs/blob/main/SNIPS/snip-8.md#protocol-changes).

---

## Deploy Account Transaction Hashes

### TransactionHashDeployAccountV1

Calculates the transaction hash for a Deploy Account V1 transaction.

#### Signature

```go
func TransactionHashDeployAccountV1(
	txn *rpc.DeployAccountTxnV1,
	contractAddress, chainID *felt.Felt,
) (*felt.Felt, error)
```

#### Parameters

- `txn` - The Deploy Account V1 transaction containing:
  - `Version` - Transaction version string
  - `ClassHash` - Hash of the account contract class
  - `ContractAddressSalt` - Salt used in address calculation
  - `ConstructorCalldata` - Constructor parameters
  - `MaxFee` - Maximum fee willing to pay
  - `Nonce` - Account nonce (usually 0 for deployment)
- `contractAddress` - The computed contract address
- `chainID` - The Starknet chain ID

#### Returns

- `*felt.Felt` - The calculated transaction hash
- `error` - Error if required parameters are missing

#### Usage Example

```go
package main

import (
	"fmt"
	"log"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/hash"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/NethermindEth/starknet.go/utils"
)

func main() {
	classHash, _ := utils.HexToFelt("0xabcdef1234567890")
	salt, _ := utils.HexToFelt("0x1234")
	contractAddr, _ := utils.HexToFelt("0x5678")

	txn := &rpc.DeployAccountTxnV1{
		Version:             "0x1",
		ClassHash:           classHash,
		ContractAddressSalt: salt,
		ConstructorCalldata: []*felt.Felt{
			new(felt.Felt).SetUint64(100),
		},
		MaxFee: new(felt.Felt).SetUint64(1000000),
		Nonce:  new(felt.Felt).SetUint64(0),
	}

	chainID := new(felt.Felt).SetBytes([]byte("SN_SEPOLIA"))

	txHash, err := hash.TransactionHashDeployAccountV1(txn, contractAddr, chainID)
	if err != nil {
		log.Fatal("Failed to calculate hash:", err)
	}

	fmt.Printf("Transaction Hash: %s\n", txHash.String())
}
```

#### Specification

Follows the [V1 Deploy Account hash calculation specification](https://docs.starknet.io/architecture-and-concepts/network-architecture/transactions/#v1_deprecated_hash_calculation_3).

---

### TransactionHashDeployAccountV3

Calculates the transaction hash for a Deploy Account V3 transaction with resource bounds.

#### Signature

```go
func TransactionHashDeployAccountV3(
	txn *rpc.DeployAccountTxnV3,
	contractAddress, chainID *felt.Felt,
) (*felt.Felt, error)
```

#### Parameters

- `txn` - The Deploy Account V3 transaction containing:
  - `Version` - Transaction version string
  - `ClassHash` - Hash of the account contract class
  - `ContractAddressSalt` - Salt used in address calculation
  - `ConstructorCalldata` - Constructor parameters
  - `Nonce` - Account nonce (usually 0 for deployment)
  - `ResourceBounds` - Resource bounds for L1 gas, L2 gas, and L1 data gas
  - `Tip` - Additional fee tip
  - `PayMasterData` - Optional paymaster data
  - `FeeMode` - Fee data availability mode
  - `NonceDataMode` - Nonce data availability mode
- `contractAddress` - The computed contract address
- `chainID` - The Starknet chain ID

#### Returns

- `*felt.Felt` - The calculated transaction hash
- `error` - Error if required parameters are missing

#### Usage Example

```go
package main

import (
	"fmt"
	"log"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/hash"
	"github.com/NethermindEth/starknet.go/rpc"
	"github.com/NethermindEth/starknet.go/utils"
)

func main() {
	classHash, _ := utils.HexToFelt("0xabcdef1234567890")
	salt, _ := utils.HexToFelt("0x1234")
	contractAddr, _ := utils.HexToFelt("0x5678")

	txn := &rpc.DeployAccountTxnV3{
		Version:             "0x3",
		ClassHash:           classHash,
		ContractAddressSalt: salt,
		ConstructorCalldata: []*felt.Felt{
			new(felt.Felt).SetUint64(100),
		},
		Nonce: new(felt.Felt).SetUint64(0),
		ResourceBounds: &rpc.ResourceBoundsMapping{
			L1Gas: rpc.ResourceBounds{
				MaxAmount:       new(felt.Felt).SetUint64(50000),
				MaxPricePerUnit: new(felt.Felt).SetUint64(100),
			},
			L2Gas: rpc.ResourceBounds{
				MaxAmount:       new(felt.Felt).SetUint64(0),
				MaxPricePerUnit: new(felt.Felt).SetUint64(0),
			},
			L1DataGas: rpc.ResourceBounds{
				MaxAmount:       new(felt.Felt).SetUint64(0),
				MaxPricePerUnit: new(felt.Felt).SetUint64(0),
			},
		},
		Tip:           new(felt.Felt).SetUint64(0),
		PayMasterData: []*felt.Felt{},
		FeeMode:       rpc.DAModeL1,
		NonceDataMode: rpc.DAModeL1,
	}

	chainID := new(felt.Felt).SetBytes([]byte("SN_SEPOLIA"))

	txHash, err := hash.TransactionHashDeployAccountV3(txn, contractAddr, chainID)
	if err != nil {
		log.Fatal("Failed to calculate hash:", err)
	}

	fmt.Printf("Transaction Hash: %s\n", txHash.String())
}
```

#### Specification

Follows the [V3 Deploy Account hash calculation specification](https://docs.starknet.io/architecture-and-concepts/network-architecture/transactions/#v3_hash_calculation_3).

---

## Deprecated Transaction Hash Common

### CalculateDeprecatedTransactionHashCommon

A low-level utility function that calculates transaction hashes using the deprecated (Pedersen-based) method. This is used internally by V0, V1, and V2 transaction hash functions.

#### Signature

```go
func CalculateDeprecatedTransactionHashCommon(
	txHashPrefix *felt.Felt,
	version *felt.Felt,
	contractAddress *felt.Felt,
	entryPointSelector *felt.Felt,
	calldata *felt.Felt,
	maxFee *felt.Felt,
	chainID *felt.Felt,
	additionalData []*felt.Felt,
) *felt.Felt
```

#### Parameters

- `txHashPrefix` - Transaction type prefix ("invoke", "declare", or "deploy_account")
- `version` - Transaction version as felt
- `contractAddress` - Contract or sender address
- `entryPointSelector` - Entry point selector (or zero for some transaction types)
- `calldata` - Hashed calldata
- `maxFee` - Maximum fee
- `chainID` - Chain ID
- `additionalData` - Additional data (nonce, compiled class hash, etc.)

#### Returns

- `*felt.Felt` - The calculated transaction hash

#### Usage Example

```go
package main

import (
	"fmt"

	"github.com/NethermindEth/juno/core/felt"
	"github.com/NethermindEth/starknet.go/curve"
	"github.com/NethermindEth/starknet.go/hash"
)

func main() {
	prefix := new(felt.Felt).SetBytes([]byte("invoke"))
	version := new(felt.Felt).SetUint64(1)
	address := new(felt.Felt).SetUint64(12345)
	selector := &felt.Zero
	calldataHash := curve.PedersenArray(new(felt.Felt).SetUint64(1))
	maxFee := new(felt.Felt).SetUint64(1000000)
	chainID := new(felt.Felt).SetBytes([]byte("SN_SEPOLIA"))
	nonce := new(felt.Felt).SetUint64(1)

	txHash := hash.CalculateDeprecatedTransactionHashCommon(
		prefix,
		version,
		address,
		selector,
		calldataHash,
		maxFee,
		chainID,
		[]*felt.Felt{nonce},
	)

	fmt.Printf("Transaction Hash: %s\n", txHash.String())
}
```

#### Note

This function is primarily used internally. Most developers should use the specific transaction hash functions (TransactionHashInvokeV1, etc.) instead of calling this directly.

---

## Version Differences

### V0 vs V1 vs V3 Transactions

- **V0 Transactions**: Legacy format, deprecated, uses Pedersen hash
- **V1/V2 Transactions**: Uses MaxFee and Pedersen hash, includes nonce
- **V3 Transactions**: Uses ResourceBounds instead of MaxFee, Poseidon hash, includes data availability modes

### Key Differences in V3

V3 transactions introduce several new concepts:

1. **Resource Bounds**: Separate limits for L1 gas, L2 gas, and L1 data gas
2. **Data Availability Modes**: Specifies where fee and nonce data is stored
3. **Tip**: Optional additional fee for transaction prioritization
4. **Poseidon Hash**: More efficient hashing algorithm
5. **PayMaster Support**: Optional third-party fee payment

## Error Handling

All transaction hash functions return errors for missing required parameters:

```go
txHash, err := hash.TransactionHashInvokeV3(txn, chainID)
if err != nil {
	if err == hash.ErrNotAllParametersSet {
		// Handle missing parameters
		log.Fatal("Transaction is missing required fields")
	}
	// Handle other errors
	log.Fatal("Failed to calculate hash:", err)
}
```

## Related Documentation

- [Class Hash Functions](./class-hash.mdx) - Calculate contract class hashes
- [Utility Functions](./utilities.mdx) - Helper functions for V3 transactions
- [RPC Methods](../rpc/) - Using transaction hashes with RPC calls
